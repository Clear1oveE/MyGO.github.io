<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/Clear1oveE/Clear1oveE.github.io/2023/11/02/%E7%B4%A0%E6%9D%90/"/>
      <url>/Clear1oveE/Clear1oveE.github.io/2023/11/02/%E7%B4%A0%E6%9D%90/</url>
      
        <content type="html"><![CDATA[<p>SSSS系列的歌曲，一直是写给那些，认为自己是主角而活着的，却在不知不觉中变回普通人，即便如此也要夺回属于自己主角地位的‘长大了的少年们‘，这次也是按照那种感觉来写歌的。因为我觉得……大家，小的时候都在模仿着英雄。虽然从大人们的视角来看，我们只不过是在沙坑里玩耍，但在我们的视角看来我们是在认真地拯救地球，我们的面前确实是有着一只打不败的怪兽存在着。我觉得那个世界绝不能是谎言。就算只是孩童们的想象，但我们所引发的、实际体验过的宇宙大爆炸的感觉是绝对应该留下来的，我一直有着这种想法，也希望大家能够再一次记住这点，希望我能够再次看到大家所心怀的宇宙，我抱着这种想法写下了这首歌。</p><p>你和我从小到大所追求的这个‘宇宙’，其实十分浪漫，即便长大后都明白那些并不存在，可是那份心情却从来没有消失过。</p><p>越是久远地爱着那个空想宇宙越是能从中体会到那份感动。<br>受困于现实迷宫的“主角们”自始至终都未能消去心中的憧憬，怀抱着希冀地冲向那个曾幻想过的未来。<br>那真切的未来大概……不，绝对与你我曾经所幻想过的不一样，那里不存在广阔的宇宙，没有红银色的巨人，未有或黑或绿或深沉或搞怪的骑士，也没有驾驭着机器人的队伍，就连恶与善的边缘都是模糊暧昧的。<br>但，那又如何呢，几度折腰于现实，与梦想和解，少年也依旧不会忘记最初所坚定的东西，少年自己就是自己的宇宙。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>题解</title>
      <link href="/Clear1oveE/Clear1oveE.github.io/2023/10/24/%E9%A2%98%E8%A7%A3/"/>
      <url>/Clear1oveE/Clear1oveE.github.io/2023/10/24/%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><blockquote><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure></blockquote><p>这个题最麻烦的是考虑两个链表不一样长时，其中一个链表在相加过程中会停下来的情况。为此需要增加很多if语句，不但判断停不停还要判断谁先停</p><ul><li>对于两个长度不一，但需要同时对链表的节点进行运算的题，我们可以将短的链表后边全部置0，当做两个长度一样的链表，运算就容易了</li><li>下面这个代码就是核心</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n1 = l1 ? l1-&gt;val: <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n2 = l2 ? l2-&gt;val: <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sum = n1 + n2 + carry;</span><br></pre></td></tr></table></figure><p>完整代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>, *tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">        <span class="type">int</span> n1 = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n2 = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = n1 + n2 + carry;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            head = tail = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">            tail-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">            tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">            tail-&gt;next-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        tail-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        tail-&gt;next-&gt;val = carry;</span><br><span class="line">        tail-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h2><blockquote><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></table></figure><p>请将其重新排列后变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1：</strong></p><p><img src="https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[1,4,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://pic.leetcode-cn.com/1626420320-YUiulT-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[1,5,2,4,3]</span><br></pre></td></tr></table></figure></blockquote><p>这道题有两种解决方法，都使用了链表的一些重要方法(但不知道为啥运行时间都很长，还不如我的笨方法？)</p><p><strong>方法一：线性表</strong></p><p>众所周知，数组的访问是非常灵活的可以通过下标访问到其中的任意元素，而链表则要笨重很多，而为了使链表灵活起来，我们可以用一个线性表储存该链表</p><p>将链表储存到线性表的核心代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reorderList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">vec</span>[40001];</span><span class="comment">//注意这里创建的线性表类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将链表存入线性表中</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        vec[n++] = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reorderList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">vec</span>[40001];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        vec[n++] = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        vec[i]-&gt;next = vec[j];</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[j]-&gt;next = vec[i];</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    vec[i]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：链表终点+链表逆序+合并链表</strong></p><p>仔细观察可以发现，目标链表是将原链表右半部分逆序后，与前半部分合并得到的，因此可以通过三个步骤解决这个问题</p><ul><li>找到链表终点(快慢链表)</li><li>将后半部分逆序</li><li>合并</li></ul><p>完整代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找链表终点</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">middleNode</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表逆序</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">nextTemp</span> =</span> curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeList</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">l1_tmp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">l2_tmp</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        l1_tmp = l1-&gt;next;</span><br><span class="line">        l2_tmp = l2-&gt;next;</span><br><span class="line"></span><br><span class="line">        l1-&gt;next = l2;</span><br><span class="line">        l1 = l1_tmp;</span><br><span class="line"></span><br><span class="line">        l2-&gt;next = l1;</span><br><span class="line">        l2 = l2_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reorderList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">mid</span> =</span> middleNode(head);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">l1</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">l2</span> =</span> mid-&gt;next;</span><br><span class="line">    mid-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    l2 = reverseList(l2);</span><br><span class="line">    mergeList(l1, l2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h2><blockquote><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;3[a2[c]]&quot;</span><br><span class="line">输出：&quot;accaccacc&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">输出：&quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc3[cd]xyz&quot;</span><br><span class="line">输出：&quot;abccdcdcdxyz&quot;</span><br></pre></td></tr></table></figure></blockquote><p>观察输入可得知，所有数字都是出现在’[‘之前的，并且每个数字都有对应的’[]’，我们要做的就是一层层的将数字与’[]’内的内容对应，将’[]’拆开，最后只剩一个单纯的由字母组成的字符串</p><p>因为我们第一步要寻找的是每个’[‘对应的’]’才能正确的拆开，由此可以想到括号匹配的问题，而不同的是我们还需要留意每个’[]’对应的数字与其中的内容</p><p>针对这个变化，我想到的是新建两个栈(b,c)，我们将遇到的所有非数字字符依次入栈(a),每次遇到’[‘就将它对应的数字入栈(b)，在遇到’]’时，就重复执行出栈操作(a),并将出栈的字符存入栈c，直到遇到’[‘为止</p><p>此时栈c的内容是要重复的字符串，栈b栈顶元素是重复次数，我们根据这两个栈，再将重复后的字符串重新入栈(a)，此时就拆开了一个’[]’，之后不断执行该操作即可</p><p>完整代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">decodeString</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="comment">//栈a，目标字符串</span></span><br><span class="line">    <span class="type">char</span> *<span class="built_in">stack</span>=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">10000</span>);</span><br><span class="line">    <span class="comment">//栈b，储存重复次数</span></span><br><span class="line">    <span class="type">int</span> *times=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">10000</span>);</span><br><span class="line">    <span class="comment">//栈c，储存要重复的字符串</span></span><br><span class="line">    <span class="type">char</span>*popNum=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">10000</span>);</span><br><span class="line">    <span class="type">int</span> repetNum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//三个栈顶</span></span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>,top2=<span class="number">0</span>,top3=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//得到&#x27;[&#x27;前的数字</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">        num=num*<span class="number">10</span>+(s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">stack</span>[top++]=s[i];</span><br><span class="line">            times[top2++]=num;</span><br><span class="line">            num=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">stack</span>[--top]!=<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                popNum[top3++]=<span class="built_in">stack</span>[top];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//得到重复次数</span></span><br><span class="line">            repetNum=times[--top2];</span><br><span class="line">            <span class="type">int</span> temp=top3;</span><br><span class="line">            <span class="comment">//重复入栈</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;repetNum;i++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(temp!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">stack</span>[top++]=popNum[--temp];</span><br><span class="line">                &#125;</span><br><span class="line">                temp=top3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每次执行重复操作后，将栈c清0</span></span><br><span class="line">            top3=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">stack</span>[top++]=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>[top]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除链表的倒数第N个结点"><a href="#删除链表的倒数第N个结点" class="headerlink" title="删除链表的倒数第N个结点"></a>删除链表的倒数第N个结点</h2><blockquote><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul></blockquote><p><strong>方法一：线性表</strong></p><p>做法跟重排链表题相似，这里就不再赘述，注意删除头结点时，数组越界情况即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">vec</span>[31];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">list</span>=</span>head;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">list</span>)&#123;</span><br><span class="line">        vec[count++]=<span class="built_in">list</span>;</span><br><span class="line">        <span class="built_in">list</span>=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">1</span>||count==<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">list</span>=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(count-n<span class="number">-1</span>&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">list</span>=vec[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        vec[count-n<span class="number">-1</span>]-&gt;next=vec[count-n]-&gt;next;</span><br><span class="line">        <span class="built_in">list</span>=vec[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：栈</strong></p><p>在遍历链表时将所有节点依次入栈，根据链表后进先出的原则，弹出的第n个节点即为要删除的节点，且栈顶元素为他的前驱</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">val</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummy</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    dummy-&gt;val = <span class="number">0</span>, dummy-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">stk</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> dummy;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Stack));</span><br><span class="line">        tmp-&gt;val = cur, tmp-&gt;next = stk;</span><br><span class="line">        stk = tmp;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">tmp</span> =</span> stk-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(stk);</span><br><span class="line">        stk = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> =</span> stk-&gt;val;</span><br><span class="line">    prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">ans</span> =</span> dummy-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(dummy);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：双指针</strong></p><p>我们要找到倒数第n个节点，我们可以设置两个指针(first,second)，第一个指针指向head，第二个指针指向哑结点，我们先让head向前遍历n次，此时第一个指针比第二个指针领先n+1，那么当第一个指针遍历结束后，第二个指针刚好指向倒数第n个节点的前驱结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummy</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    dummy-&gt;val = <span class="number">0</span>, dummy-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">first</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">second</span> =</span> dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first) &#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">ans</span> =</span> dummy-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(dummy);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h2><blockquote><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p></blockquote><p>对于这种需要找到链表终点的题我们可以使用，快慢指针的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)   <span class="comment">//条件一个都不能少，因为链表节点个数可能为为奇数或偶数   </span></span><br><span class="line">&#123;</span><br><span class="line">slow=slow-&gt;next;</span><br><span class="line">fast=fast-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当fast结束后，偶数链表slow会停在终点右边，奇数停在中间</li><li>在指针进行移动时，我们就可以把慢指针所指向的元素全部入栈，递归结束后再一个一个与后半部分判断是否相等</li><li>注意奇数情况下，fast结束后，slow指针还需再往下一格</li></ul><p>完整代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">fast</span>=</span>head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">slow</span>=</span>head;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">stack</span>[<span class="number">50000</span>];</span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> jud=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)&#123;</span><br><span class="line">        <span class="built_in">stack</span>[top++]=slow-&gt;val;</span><br><span class="line">        fast=fast-&gt;next-&gt;next;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast)</span><br><span class="line">    slow=slow-&gt;next;</span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">for</span>(;slow;slow=slow-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stack</span>[top]!=slow-&gt;val)&#123;</span><br><span class="line">            jud=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jud;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="去除重复字母"><a href="#去除重复字母" class="headerlink" title="去除重复字母"></a>去除重复字母</h2><blockquote><p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 <strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;bcabc&quot;</span><br><span class="line">输出：&quot;abc&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cbacdcbc&quot;</span><br><span class="line">输出：&quot;acdb&quot;</span><br></pre></td></tr></table></figure></blockquote><p>因为不允许改变顺序，我们可以通过栈来解决这道题</p><p>当确定了栈的数据结构后，我们思考问题最好从每个入栈元素的和栈顶元素角度上去考虑</p><p>以此题为例，遍历输入的每个字母，我们都对栈顶元素与当前元素进行判断，为了使字典序最小，我们需要保证在不破坏顺序的基础上，把较小元素留在前面，把较大元素放在后面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aba 删除后面那个a，输出ab</span><br><span class="line">cbc 删除前面那个c，输出bc</span><br></pre></td></tr></table></figure><p>将问题简化我们很快就能发现解决方法</p><ul><li>对于每一个即将入栈的元素，如果比栈顶元素小并且栈顶元素后面还有重复的，直接将栈顶元素出栈（可以一下出栈很多个，此时是cbc情况），然后将当前元素入栈</li><li>如果发现前面已有相同元素（即说明前面那个相同元素的下一个肯定比他大，此时是aba情况，直接出栈就行），则直接遍历下一个，不做处理</li><li>其他情况直接入栈即可</li></ul><p>Note：</p><ul><li>当子函数要求返回一个指针时，不能return数组的首地址，最好用malloc函数生成数组</li></ul><p>完整代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">removeDuplicateLetters</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> book[<span class="number">28</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)&#123;</span><br><span class="line">        book[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;<span class="comment">//记录每个字母出现的次数</span></span><br><span class="line">    <span class="type">int</span> top=<span class="number">-1</span>;</span><br><span class="line">     <span class="type">char</span>*<span class="built_in">stack</span>=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">30</span>);<span class="comment">//声明数组</span></span><br><span class="line">    <span class="type">bool</span> find=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//需要入栈的数s[i],栈顶元素satck[top]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=top;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="built_in">stack</span>[j])&#123;</span><br><span class="line">                book[s[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                find=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//遍历前面的元素，检查是否有相同的，有就直接遍历下一个</span></span><br><span class="line">        <span class="keyword">if</span>(find)&#123;</span><br><span class="line">            find=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(top&gt;=<span class="number">0</span>&amp;&amp;s[i]&lt;<span class="built_in">stack</span>[top]&amp;&amp;book[<span class="built_in">stack</span>[top]-<span class="string">&#x27;a&#x27;</span>]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            book[<span class="built_in">stack</span>[top]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;<span class="comment">//重复执行出栈检查</span></span><br><span class="line">        <span class="built_in">stack</span>[++top]=s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>[++top]=<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//返回字符数组，别忘了在结尾添加&#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件的最长绝对路径"><a href="#文件的最长绝对路径" class="headerlink" title="文件的最长绝对路径"></a>文件的最长绝对路径</h2><blockquote><p>假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：</p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mdir.jpg" alt="img"></p><p>这里将 <code>dir</code> 作为根目录中的唯一目录。<code>dir</code> 包含两个子目录 <code>subdir1</code> 和 <code>subdir2</code> 。<code>subdir1</code> 包含文件 <code>file1.ext</code> 和子目录 <code>subsubdir1</code>；<code>subdir2</code> 包含子目录 <code>subsubdir2</code>，该子目录下包含文件 <code>file2.ext</code> 。</p><p>在文本格式中，如下所示(⟶表示制表符)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br><span class="line">⟶ subdir1</span><br><span class="line">⟶ ⟶ file1.ext</span><br><span class="line">⟶ ⟶ subsubdir1</span><br><span class="line">⟶ subdir2</span><br><span class="line">⟶ ⟶ subsubdir2</span><br><span class="line">⟶ ⟶ ⟶ file2.ext</span><br></pre></td></tr></table></figure><p>如果是代码表示，上面的文件系统可以写为 <code>&quot;dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext&quot;</code> 。<code>&#39;\n&#39;</code> 和 <code>&#39;\t&#39;</code> 分别是换行符和制表符。</p><p>文件系统中的每个文件和文件夹都有一个唯一的 <strong>绝对路径</strong> ，即必须打开才能到达文件&#x2F;目录所在位置的目录顺序，所有路径用 <code>&#39;/&#39;</code> 连接。上面例子中，指向 <code>file2.ext</code> 的 <strong>绝对路径</strong> 是 <code>&quot;dir/subdir2/subsubdir2/file2.ext&quot;</code> 。每个目录名由字母、数字和&#x2F;或空格组成，每个文件名遵循 <code>name.extension</code> 的格式，其中 <code>name</code> 和 <code>extension</code>由字母、数字和&#x2F;或空格组成。</p><p>给定一个以上述格式表示文件系统的字符串 <code>input</code> ，返回文件系统中 <em>指向 <strong>文件</strong> 的 <strong>最长绝对路径</strong> 的长度</em> 。 如果系统中没有文件，返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/dir1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：input = &quot;dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext&quot;</span><br><span class="line">输出：20</span><br><span class="line">解释：只有一个文件，绝对路径为 &quot;dir/subdir2/file.ext&quot; ，路径长度 20</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/dir2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：input = &quot;dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext&quot;</span><br><span class="line">输出：32</span><br><span class="line">解释：存在两个文件：</span><br><span class="line">&quot;dir/subdir1/file1.ext&quot; ，路径长度 21</span><br><span class="line">&quot;dir/subdir2/subsubdir2/file2.ext&quot; ，路径长度 32</span><br><span class="line">返回 32 ，因为这是最长的路径</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：input = &quot;a&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在任何文件</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：input = &quot;file1.txt\nfile2.txt\nlongfile.txt&quot;</span><br><span class="line">输出：12</span><br><span class="line">解释：根目录下有 3 个文件。</span><br><span class="line">因为根目录中任何东西的绝对路径只是名称本身，所以答案是 &quot;longfile.txt&quot; ，路径长度为 12</span><br></pre></td></tr></table></figure></blockquote><p>因为让我们求的是长度，所以我们在解决这道题目时，不需要保存相对路径的字符串，只需要保存长度即可</p><p>在这种思路下，我们简化问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a        lenSum=len(a)</span><br><span class="line">a\b      lenSum=len(a)+len(b)+1</span><br><span class="line">a\b\c.x  lenSum=len(a)+len(b)+1+len(c.x)+1</span><br></pre></td></tr></table></figure><p>由此发现，我们只需要储存每一级目录的父目录的长度，当前目录的长度只需要在父目录长度基础上加当前目录的长度即可</p><p>在遍历时，我们是分别遍历完每个分支，再去找下一个分支的长度，与寻找迷宫出口的最短路径类似，我们可以使用类似回溯法的方法</p><p>所以我们此时可以选择栈这种数据结构来保存，每一个节点用来保存不同深度的长度</p><p>我们可以用top来保存栈顶的深度，用depth表示当前路径的深度，当当前路径深度小于当前路径的深度，则表明当前节点并不是栈顶节点的孩子节点，按照先序遍历的顺序，则此时需要进行回退直到栈顶节点为当前节点的父亲节点（top–），然后再求出当前节点的路径与长度。</p><p>完整代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lengthLongestPath</span><span class="params">(<span class="type">char</span> *input)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>; <span class="comment">// 栈顶深度</span></span><br><span class="line">    <span class="type">int</span> depth = <span class="number">1</span>, len = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(input);</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">stack</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    <span class="type">bool</span> isFind = <span class="literal">false</span>; <span class="comment">// 是否找到文件</span></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        depth = <span class="number">1</span>; <span class="comment">// 每次遇到换行后都要重新初始化</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        isFind = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 计算深度</span></span><br><span class="line">        <span class="keyword">while</span> (pos &lt; n &amp;&amp; input[pos] == <span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算当前深度的路径长度</span></span><br><span class="line">        <span class="keyword">while</span> (pos &lt; n &amp;&amp; input[pos] != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (input[pos] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                isFind = <span class="literal">true</span>;</span><br><span class="line">            len++;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳过换行符</span></span><br><span class="line">        pos++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证栈顶深度一定刚好比当前深度小1，即找到父目录</span></span><br><span class="line">        <span class="keyword">while</span> (top &gt;= depth)</span><br><span class="line">            top--;</span><br><span class="line">        <span class="comment">//有父目录的情况下才可以进行相加</span></span><br><span class="line">        <span class="keyword">if</span> (top &gt; <span class="number">0</span>)</span><br><span class="line">            len += <span class="built_in">stack</span>[top - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">stack</span>[top++] = len;</span><br><span class="line">        <span class="keyword">if</span> (isFind)</span><br><span class="line">            <span class="keyword">if</span> (len &gt; max)</span><br><span class="line">                max = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单计数器"><a href="#简单计数器" class="headerlink" title="简单计数器"></a>简单计数器</h2><blockquote><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>整数除法仅保留整数部分。</p><p>你可以假设给定的表达式总是有效的。所有中间结果将在 <code>[-231, 231 - 1]</code> 的范围内。</p><p><strong>注意：</strong>不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;3+2*2&quot;</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot; 3/2 &quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot; 3+5 / 2 &quot;</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由整数和算符 <code>(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)</code> 组成，中间由一些空格隔开</li><li><code>s</code> 表示一个 <strong>有效表达式</strong></li><li>表达式中的所有整数都是非负整数，且在范围 <code>[0, 231 - 1]</code> 内</li><li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li></ul></blockquote><p>这种不带括号的计数器，核心理念就是把所有的计算都转换成加法进栈，</p><p>例如：1+2*5-7</p><ul><li>1进栈</li><li>2*5&#x3D;10进栈（除法同理）</li><li>-7进栈</li></ul><p>根据这个例子，我们可以得出对栈进行操作的方法</p><ul><li>加法直接进栈</li><li>减法取相反数进栈</li><li>乘法&#x2F;除法则是与栈顶元素相乘</li></ul><p>最后将栈中元素相加即可</p><p>对于一个计算来说，总是a#b@c的形式，观察得知当检测到第一个运算符#时，我们并不知道b的值，故无法运算对栈进行操作，只有观察到第二个运算符@时，我们才知道a#b的值</p><p>由此，我们则能用一个preSign保存上一个运算符，当检查到新的运算符时，利用preSign对栈中元素进行操作</p><p>具体实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tep是当前数字     </span></span><br><span class="line">     <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i])&amp;&amp;s[i]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">switch</span>(preSign)&#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="built_in">stack</span>[top++]=tep;<span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:<span class="built_in">stack</span>[top++]=-tep;<span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:<span class="built_in">stack</span>[top<span class="number">-1</span>]*=tep;<span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:<span class="built_in">stack</span>[top<span class="number">-1</span>]/=tep;<span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          preSign=s[i];</span><br><span class="line">          tep=<span class="number">0</span>;            </span><br></pre></td></tr></table></figure><p>注意，我需要初始化preSign为+，使第一元素能顺利进栈</p><p>完整代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">     <span class="type">int</span>*<span class="built_in">stack</span>=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*len);</span><br><span class="line">    <span class="type">int</span> tep=<span class="number">0</span>,top=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> preSign=<span class="string">&#x27;+&#x27;</span>;<span class="comment">//初始化，使第一个元素进栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="comment">//因为是字符串，所以通过循环的方法得到具体的整数是多少</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">            tep=tep*<span class="number">10</span>+(s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i])&amp;&amp;s[i]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(preSign)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="built_in">stack</span>[top++]=tep;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:<span class="built_in">stack</span>[top++]=-tep;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:<span class="built_in">stack</span>[top<span class="number">-1</span>]*=tep;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:<span class="built_in">stack</span>[top<span class="number">-1</span>]/=tep;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            preSign=s[i];</span><br><span class="line">            tep=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;top;i++)&#123;</span><br><span class="line">        sum+=<span class="built_in">stack</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>题目</title>
      <link href="/Clear1oveE/Clear1oveE.github.io/2023/10/06/%E9%A2%98%E7%9B%AE/"/>
      <url>/Clear1oveE/Clear1oveE.github.io/2023/10/06/%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="求最小公倍数-x2F-最大公因数"><a href="#求最小公倍数-x2F-最大公因数" class="headerlink" title="求最小公倍数&#x2F;最大公因数"></a>求最小公倍数&#x2F;最大公因数</h1><p><strong>最大公因数</strong></p><p>假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：</p><p>1997 &#x2F; 615 &#x3D; 3 (余 152)</p><p>615 &#x2F; 152 &#x3D; 4(余7)</p><p>152 &#x2F; 7 &#x3D; 21(余5)</p><p>7 &#x2F; 5 &#x3D; 1 (余2)</p><p>5 &#x2F; 2 &#x3D; 2 (余1)</p><p>2 &#x2F; 1 &#x3D; 2 (余0)</p><p>至此，最大公约数为1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num1,num2,tem;<span class="comment">//num1，num2是输入的两个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;num1,&amp;num2);</span><br><span class="line">    <span class="keyword">while</span>(num2)&#123;</span><br><span class="line">        tem=num1;</span><br><span class="line">        num1=num2;</span><br><span class="line">        num2=tem%num2;</span><br><span class="line">    &#125;<span class="comment">//当num2=0时，num1就是最大公约数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最小公倍数</strong></p><p>最小公倍数就是两数相乘再除以最小公倍数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findmax</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num1,num2,max,min;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;num1,&amp;num2);</span><br><span class="line">    max=findmax(num1,num2);<span class="comment">//最大公约数</span></span><br><span class="line">    min=num1*num2/max;<span class="comment">//最小公倍数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,min)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">findmax</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tem;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        tem=a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=tem%b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;<span class="comment">//找最大公约数</span></span><br></pre></td></tr></table></figure><h1 id="链表相加"><a href="#链表相加" class="headerlink" title="链表相加"></a>链表相加</h1><blockquote><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>], l2 = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">7</span>,<span class="number">0</span>,<span class="number">8</span>]</span><br><span class="line">解释：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>关键在于t的运用，t能用于进位和结束的判断，神来之笔！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummy</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> dummy;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1 || l2 || t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1) t += l1-&gt;val,l1=l1-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(l2) t += l2-&gt;val,l2=l2-&gt;next;</span><br><span class="line">        cur-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        cur-&gt;next-&gt;val = t%<span class="number">10</span>;</span><br><span class="line">        cur-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="哈希排序"><a href="#哈希排序" class="headerlink" title="哈希排序"></a>哈希排序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到数组中的最大值</span></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建哈希表并初始化为0</span></span><br><span class="line">    <span class="type">int</span>* hashTable = (<span class="type">int</span>*)<span class="built_in">calloc</span>(max + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个元素的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        hashTable[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据哈希表进行排序</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; hashTable[i]; j++) &#123;</span><br><span class="line">            arr[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放哈希表的内存</span></span><br><span class="line">    <span class="built_in">free</span>(hashTable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    countingSort(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorted array: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端</title>
      <link href="/Clear1oveE/Clear1oveE.github.io/2023/10/05/%E5%89%8D%E7%AB%AF/"/>
      <url>/Clear1oveE/Clear1oveE.github.io/2023/10/05/%E5%89%8D%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="VScode快捷键"><a href="#VScode快捷键" class="headerlink" title="VScode快捷键"></a>VScode快捷键</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码格式化</span></span><br><span class="line">Shift+Alt+F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向上或向下移动一行</span></span><br><span class="line">Alt+Up或Alt+down</span><br><span class="line"></span><br><span class="line"><span class="comment">#快速复制一行代码</span></span><br><span class="line">Shift+Alt+Up或Shift+Alt+down</span><br><span class="line"></span><br><span class="line"><span class="comment">#快速查找</span></span><br><span class="line">Ctrl+F</span><br><span class="line"></span><br><span class="line"><span class="comment">#快速替换</span></span><br><span class="line">Ctrl+H</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速补全</span></span><br><span class="line">!+回车</span><br></pre></td></tr></table></figure><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="基础骨架"><a href="#基础骨架" class="headerlink" title="基础骨架"></a>基础骨架</h2><p><code>&lt;!DOCTYPE html&gt;</code>是H5的声明位于文档的最前面，是网页必备的组成部分，避免浏览器的怪异模式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>html标签</strong></p><p>定义HTML文档，看到这个标签后我们就明白这是个HTML文档，其他元素要包裹在里面，标签限定了文档的开始点和结束点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="head标签"><a href="#head标签" class="headerlink" title="head标签"></a>head标签</h3><p>head标签用于定义文档的头部。文档的头部描述了文档的各种属性和信息，包括文档的标题，在Web中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会作为内容显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="body标签"><a href="#body标签" class="headerlink" title="body标签"></a>body标签</h3><p>body元素定义文档的主体</p><p>body元素包含文档的所有内容（比如文本，超链接，图像，表格和列表等）</p><p>它会直接在页面中显示出来，也就是用户可以直观看到的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        我会显示在浏览器中</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="title标签"><a href="#title标签" class="headerlink" title="title标签"></a>title标签</h3><p>可定义文档的标题</p><p>他会显示在浏览器窗口的标题栏或状态栏上</p><p>title标签是head标签中唯一必须包含的东西，也就是说写head一定要写title</p><p>title的增加有利于SEO优化</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        我会显示在浏览器中</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h3><p><code>&lt;meta&gt;</code>标签用来描述一个HTML网页文档的属性，关键词等，包含在head标签中，如：<code>charset=&quot;utf-8&quot;</code>是说当前使用的是utf-8编码格式，在开发中我们经常会看到utf-8或是gbk</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        我会显示在浏览器中</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="标题标签-lt-h-gt"><a href="#标题标签-lt-h-gt" class="headerlink" title="标题标签&lt;h&gt;"></a>标题标签&lt;h&gt;</h2><p>挑剔通过<code>&lt;h1&gt;</code>-<code>&lt;h6&gt;</code>标签定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure><p>快速生成x级标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h$*x</span><br></pre></td></tr></table></figure><ul><li>请将HTML标签只用于标签</li><li>不要仅仅为了生成粗体文本而使用标题</li><li>正确标题有益于SEO</li></ul><h2 id="段落，换行，水平线标签"><a href="#段落，换行，水平线标签" class="headerlink" title="段落，换行，水平线标签"></a>段落，换行，水平线标签</h2><h3 id="段落标签-lt-p-gt"><a href="#段落标签-lt-p-gt" class="headerlink" title="段落标签&lt;p&gt;"></a>段落标签&lt;p&gt;</h3><p>段落标签里放要写的文本内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    文本</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="换行-lt-br-gt"><a href="#换行-lt-br-gt" class="headerlink" title="换行&lt;br&gt;"></a>换行&lt;br&gt;</h3><p>换行<code>&lt;br&gt;</code>是一个空的HTML元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>My dance is not over yet<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>May all<span class="tag">&lt;<span class="name">br</span>&gt;</span> the beauty be blessed<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="水平线-lt-hr-gt"><a href="#水平线-lt-hr-gt" class="headerlink" title="水平线&lt;hr&gt;"></a>水平线&lt;hr&gt;</h3><p><code>&lt;hr&gt;</code>标签在HTML中创建水平线，其有四个参数值</p><ul><li>color：设置水平线的颜色</li><li>width：设置水平线的长度</li><li>size：设置水平线的高度</li><li>align：设置水平线的对齐方式（默认居中），可取left，right</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>My dance is not over yet<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>May all<span class="tag">&lt;<span class="name">br</span>&gt;</span> the beauty be blessed<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span><span class="attr">width</span>=<span class="string">&quot;2000px&quot;</span><span class="attr">size</span>=<span class="string">&quot;20px&quot;</span><span class="attr">align</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="标签之图片-lt-img-gt"><a href="#标签之图片-lt-img-gt" class="headerlink" title="标签之图片&lt;img&gt;"></a>标签之图片&lt;img&gt;</h2><p><code>&lt;img&gt;</code>标签定义HTML页面中的图像</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span><span class="attr">alt</span>=<span class="string">&quot;&quot;</span><span class="attr">title</span>=<span class="string">&quot;&quot;</span><span class="attr">width</span>=<span class="string">&quot;&quot;</span><span class="attr">height</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意事项</strong></p><p><code>&lt;img&gt;</code>是单标签，不需要进行闭合操作</p><p><font color="red">想要放入的图片必须与html文件在同一目录下</font></p></blockquote><p>属性：</p><ul><li>src：路径（图片地址与名字）</li><li>alt：规定图像的替代文本（图片无法显示时显示的文本）</li><li>width：图像宽度</li><li>height：图像高度(一般只规定宽度，改变高度会使图片拉伸)</li><li>title：鼠标悬停在图片上给予提示</li></ul><h2 id="图片路径详解"><a href="#图片路径详解" class="headerlink" title="图片路径详解"></a>图片路径详解</h2><p><strong>绝对路径</strong></p><p>绝对路径是电脑的盘符存储与访问的具体地址，通过盘符来进入访问的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;C:\Users\谢承龙\Pictures\Saved Pictures\TrNyteal老师作品临摹\100728200_p14_master1200.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>相对路径</strong></p><p>两者的相对关系，两者在同一路径下可以直接访问</p><ul><li>子级关系：<code>/</code></li><li>父级关系：<code>../</code></li><li>同级关系：<code>./</code>(可以省略)</li></ul><p><strong>网络路径</strong></p><p>直接复制网络上的图片地址</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://i1.hdslb.com/bfs/archive/f553847942582e4e34e6296ca7f9e62ee6cbeb25.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="超链接-lt-a-gt"><a href="#超链接-lt-a-gt" class="headerlink" title="超链接&lt;a&gt;"></a>超链接&lt;a&gt;</h2><p>HTML使用标签<code>&lt;a&gt;</code>来设置超文本连接</p><p>超链接可以是一个一个字，一个词，或是一幅图像，可以点击这些内容来跳转到新的文档或者当前文档的某个部分</p><p>在标签<code>&lt;a&gt;</code>中使用了<code>href</code>属性来描述链接的地址</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>链接文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><p>常用文本标签：</p><ul><li><code>&lt;em&gt;</code>:定义着重文字</li><li><code>&lt;b&gt;:</code>定义粗体文字</li><li><code>&lt;i&gt;</code>:定义斜体字</li><li><code>&lt;strong&gt;</code>:定义加重语气</li><li><code>&lt;del&gt;</code>:定义删除字</li><li><code>&lt;span&gt;</code>:元素没有特定的含义</li></ul><blockquote><p><strong>特别提示</strong></p><p>文本标签与段落标签不同，段落代表一段文本，文本标签表示文本词汇</p></blockquote><h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><h3 id="有序列表-lt-ol-gt"><a href="#有序列表-lt-ol-gt" class="headerlink" title="有序列表&lt;ol&gt;"></a>有序列表&lt;ol&gt;</h3><p>有序列表始于<code>&lt;ol&gt;</code>标签。每个列表始于<code>&lt;li&gt;</code>标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>clear<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>love<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>type属性</strong></p><p><code>&lt;ol&gt;</code>的属性type拥有的选项：</p><ul><li>1：表示列表项目用数字符号</li><li>a：表示列表项目用小写字母符号</li><li>A：表示列表项目用大写字母符号</li><li>i：表示列表项目用小写罗马数字标号</li><li>I：表示列表用大写罗马数字标号</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>clear<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>love<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>列表可以嵌套</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span>IG<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">           FPX</span><br><span class="line">           <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">li</span>&gt;</span>Gimgoon<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">li</span>&gt;</span>Tian<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">li</span>&gt;</span>Doinb<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">li</span>&gt;</span>Lwx<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">li</span>&gt;</span>Crisp<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span>EDG<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="无序列表-lt-ul-gt"><a href="#无序列表-lt-ul-gt" class="headerlink" title="无序列表&lt;ul&gt;"></a>无序列表&lt;ul&gt;</h3><p>无序列表始于<code>&lt;ul&gt;</code>标签。每个列表项始于<code>&lt;li&gt;</code>标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>bb<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>type</strong></p><p><code>&lt;ul&gt;</code>的属性type拥有的选项</p><ul><li>disc：默认实心圆</li><li>circle：空心圆</li><li>square：小方块</li><li>none：不显示</li></ul><p><strong>常见应用场景</strong></p><ul><li>无序的列表效果</li><li>导航效果（后期通过css来修改位置）</li></ul><p>导航效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Xiaomi手机<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Redmi红米<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>笔记本<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>快捷键</strong></p><p>快速生成ul+li的布局：ul&gt;li*3(数字根据自己的需要的li进行修改)</p></blockquote><h2 id="表格标签-lt-table-gt-lt-tr-gt-lt-td-gt"><a href="#表格标签-lt-table-gt-lt-tr-gt-lt-td-gt" class="headerlink" title="表格标签&lt;table&gt;,&lt;tr&gt;,&lt;td&gt;"></a>表格标签&lt;table&gt;,&lt;tr&gt;,&lt;td&gt;</h2><p>表格标签：</p><ul><li>表格：<code>&lt;table&gt;</code></li><li>行：<code>&lt;tr&gt;</code></li><li>列：<code>&lt;td&gt;</code></li></ul><blockquote><p><strong>快捷键</strong>：</p><p>table&gt;tr<em>3&gt;td</em>4{想要输入的内容}</p></blockquote><ul><li>表格横向合并：<code>colspan</code></li><li>表格纵向合并：<code>rowspan</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>单元格6<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Form表单"><a href="#Form表单" class="headerlink" title="Form表单"></a>Form表单</h2><p>表单在Web网页中用来给用户填写信息，从而能采集用户信息，使网页具有交互的功能。</p><p>所有的用户输入内容的地方都用表单来填写，如登录注册，搜索框</p><p>表单是由容器和控件组成的，一个表单一般应该包含用户填写信息的输入框，按钮等，这些输入框，按钮叫做控件，表单就是容器，它能够容纳各种各样的控件</p><p><strong>表单元素</strong></p><p>一个完整的表单包含三个基本组成部分：</p><ul><li>表单标签</li><li>表单域</li><li>表单按钮</li></ul><p><strong>文本框</strong></p><p>文本域通过<code>&lt;input type=&quot;text&quot;&gt;</code>标签来设定，当用户要在表单中键入字母，数字等内容时，会用到文本域</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">       First name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       Last name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>密码框</strong></p><p>密码字段通过标签<code>&lt;input type=&quot;password&quot;&gt;</code>来定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>提交按钮</strong></p><p>当用户单击确定按钮时，表单的内容会被传送到另一个文件，value可以改变submit按钮的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">       First name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">       Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span><span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="块元素和行内元素"><a href="#块元素和行内元素" class="headerlink" title="块元素和行内元素"></a>块元素和行内元素</h2><p><strong>块元素</strong></p><ul><li>在页面中独占一行（自上向下垂直排列）</li><li>可以设置width，height属性</li><li>一般块级元素可以包括行内元素和其他块级元素</li></ul><p>eg：</p><blockquote><p>div,form,h1~h6,hr,p,table,ul等</p></blockquote><p><strong>行内元素</strong></p><ul><li>不会独占页面中的一行，只占自身大小</li><li>设置宽高无用</li><li>行内元素不包含块级元素</li></ul><p>eg：</p><blockquote><p>a,b,em,i,span,strong等</p></blockquote><p><strong>行内块级元素（特点：不换行，能够识别宽高）</strong></p><blockquote><p>button,img,input等</p></blockquote><h2 id="HTML5新标签"><a href="#HTML5新标签" class="headerlink" title="HTML5新标签"></a>HTML5新标签</h2><p>补充：</p><p><code>div</code>容器元素，页面中见到最多的元素，通过<code>div</code>来分块</p><p>div实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HTML5实现：</p><ul><li><code>&lt;header&gt;</code>头部</li><li><code>&lt;nav&gt;</code>导航</li><li><code>&lt;section&gt;</code>定义文档中的节，比如章节，页眉，页脚</li><li><code>&lt;aside&gt;</code>侧边栏</li><li><code>&lt;footer&gt;</code>脚部</li><li><code>&lt;article&gt;</code>代表一个独立的相关内容块，例如一篇完整的论坛帖子，一篇博客文章，一个用户评论等</li></ul><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>CSS规则由两个主要的部分构成：选择器，以及一条或多条声明</p><p>选择器通常是需要改变的HTML元素</p><p>每条声明有一个属性和一个值组成</p><p>属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值，属性和值被冒号分开</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">h3</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>:blue;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="CSS的引入方式"><a href="#CSS的引入方式" class="headerlink" title="CSS的引入方式"></a>CSS的引入方式</h2><h3 id="内联样式（行内样式）"><a href="#内联样式（行内样式）" class="headerlink" title="内联样式（行内样式）"></a>内联样式（行内样式）</h3><p>直接在相关标签中使用<code>style</code>属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:red;font-size:30px;&quot;</span></span></span><br></pre></td></tr></table></figure><blockquote><p><strong>温馨提示</strong></p><p>缺乏整体性和规划性，不利于维护</p></blockquote><h3 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a>内部样式</h3><p>在<code>&lt;head&gt;</code>内部通过<code>&lt;style&gt;</code>来改变HTML元素，在单个html可行，但在多个html文件中较为复杂</p><blockquote><p><strong>温馨提示</strong></p><p>在单个页面内的CSS代码具有统一性和规划性；便于维护，但在多个页面之间容易混乱</p></blockquote><h3 id="外部样式（推荐）"><a href="#外部样式（推荐）" class="headerlink" title="外部样式（推荐）"></a>外部样式（推荐）</h3><p>当样式需要应用与很多页面时，外部样式将是理想的选择。在使用外部样式的情况下，可以通过改变一个文件来改变整个站点的外观。每个页面用<code>&lt;link&gt;</code>标签链接到样式表。<code>&lt;link&gt;</code>标签在文档的头部</p><ul><li>新建一个<code>public.css</code>文件保存样式属性</li><li>在每个需要引用的文件<code>&lt;head&gt;</code>中引入<code>&lt;link&gt;</code>标签</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;public.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="全局选择器"><a href="#全局选择器" class="headerlink" title="全局选择器"></a>全局选择器</h3><p>可以与任何元素匹配，优先级最低，一般做样式的初始化</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    color:green;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><p>HTML文档中的元素,<code>p,b,div,a,img,body</code>等</p><p>选择页面上所有这种类型的标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>学完<span class="tag">&lt;<span class="name">span</span>&gt;</span>前端<span class="tag">&lt;/<span class="name">span</span>&gt;</span>继续学java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>规定用圆点<code>.</code>来定义，针对你想要的所有标签使用，非常灵活</p><ul><li>把想要修改的标签增添一个属性</li><li>针对属性来进行样式的修改</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>计算机好难啊啊啊啊啊<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>下辈子再也不学计算机了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>emo1!!!!!!!!!!!!!!!!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.content</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>类选择器可以被多种标签使用</li><li>类名不能以数字开头</li><li>同一个标签可以使用多个类选择器，用空格隔开</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;content size&quot;</span>&gt;</span>emo1!!!!!!!!!!!!!!!!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> .content&#123;</span><br><span class="line">            color:red;</span><br><span class="line">        &#125;</span><br><span class="line"> .size&#123;</span><br><span class="line">            color:green;</span><br><span class="line">            font-size: 30px;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><p>针对某一个特定的标签来使用，只能使用一次。<code>css</code>中的ID选择器以<code>#</code>来定义</p><p>ID是唯一的，不能重复，且不能以数字开头</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span>&gt;</span>emo住<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">#txt&#123;</span><br><span class="line">            color:red;</span><br><span class="line">            font-size: 30px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="合并选择器"><a href="#合并选择器" class="headerlink" title="合并选择器"></a>合并选择器</h3><p>语法：<code>选择器1，选择器2...&#123;&#125;</code></p><p>作用：提取共同的样式，减少重复的代码</p><p>合并的可以是标签，也可以是类,ID，也可以是类和标签和ID的混合</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p,h3&#123;</span><br><span class="line">           color:greenyellow;</span><br><span class="line">           font-size: 30px;</span><br><span class="line">       &#125;</span><br><span class="line">.t1,.t2&#123;</span><br><span class="line">           color:greenyellow;</span><br><span class="line">           font-size: 30px;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><p>行内样式&gt;ID选择器&gt;类选择器&gt;元素选择器</p><p>同级别按执行顺序生效</p><h2 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h2><p><strong>color</strong></p><p>规定文本颜色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color:green;</span><br><span class="line">color:#00ff00;</span><br><span class="line">color:rgb(0,255,0);</span><br><span class="line">color:rgba(0,255,0,0.5);</span><br></pre></td></tr></table></figure><p><strong>font-size</strong></p><p>规定字体大小，谷歌浏览器能接受的最小字体大小是12px</p><p><strong>font-weight</strong></p><p>设置文本粗细</p><ul><li>bold：定义粗体字符</li><li>bolder：定义更粗的字符</li><li>lighter：定义更细的字符</li><li>100~900：定义又细到粗 400等同默认，700等同bold</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">     color:rgba(0,255,0,1);</span><br><span class="line">     font-weight: 700;</span><br><span class="line">     font-size:30px;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>font-style</strong></p><p>指定文本的字体样式</p><ul><li>normal：默认值</li><li>italic：定义斜体字</li></ul><p><strong>font-family</strong></p><p>制定一个元素的字体</p><h2 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h2><p>CSS的背景属性主要由以下几个：</p><ul><li>background-color：设置背景颜色</li><li>background-image：设置背景图片</li><li>background-position：设置背景图片显示位置</li><li>background-repeat：设置背景图片如何填充</li><li>background-size：设置背景图片大小属性</li></ul><p><strong>background-repeat</strong></p><p>该属性设置如何平铺背景图像（有时候规定区域太大，图像太小就会出现图像重复填充的状况）</p><ul><li>repeat-x：只向水平方向平铺</li><li>repeat-y：只向垂直方向平铺</li><li>no-repeat：不平铺</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box2&#123;</span><br><span class="line">            width:1200px;</span><br><span class="line">            height: 1200px;</span><br><span class="line">            background-image: url(1.png);</span><br><span class="line">            background-repeat: no-repeat;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>background-size</strong></p><ul><li>length：设置背景图片的宽度和高度，第一个值宽度，第二个值高度</li><li>percentage：计算相对区域位置的百分比，第一个值宽度，第二个值高度</li><li>cover（一般都用cover）：保持图片纵横比并将图片缩放成完全覆盖背景区域的最小大小</li><li>contain：保持图片纵横比并将图片缩放成适合背景区域的最大大小</li></ul><p><strong>background-position</strong></p><p>设置背景图像的起始位置，默认值是0%0%</p><p>五个可选地方：left，right，center，top，bottom</p><p>用其中两个进行组合选择,当然也可以用两个百分数表示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box2&#123;</span><br><span class="line">            width:400px;</span><br><span class="line">            height: 400px;</span><br><span class="line">            background-image: url(1.png);</span><br><span class="line">            background-repeat: no-repeat;</span><br><span class="line">            background-position: center center;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><ul><li><strong>text-align</strong>：指定元素文本的水平对齐方式</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-align: center;</span><br></pre></td></tr></table></figure><ul><li><strong>text-decoration</strong>：规定添加到文本的修饰，下划线，上划线，删除线<ul><li>underline：下划线</li><li>overline：上划线</li><li>line-through：删除线</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-decoration: underline;</span><br></pre></td></tr></table></figure><ul><li><strong>text-transform</strong>：控制文本的大小写<ul><li>capitalize：定义每个单词开头大写</li><li>uppercase：定义全部大写字母</li><li>lowercase：定义全部小写字母</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-transform: capitalize;</span><br></pre></td></tr></table></figure><ul><li><strong>text-indent</strong>：规定文本框首行的缩进</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-indent: 10px;</span><br></pre></td></tr></table></figure><h2 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h2><p><strong>表格边框</strong></p><p>指定CSS表格边框，使用border属性,有三个参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table,td&#123;</span><br><span class="line">           border:1px solid red;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>折叠边框</strong></p><p>border-collapse属性设置表格的边框是否被折叠成一个单一的边框或隔开</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">table,td&#123;</span><br><span class="line">            border:1px solid red;</span><br><span class="line">            border-collapse: collapse;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>表格宽度和高度</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">table&#123;</span><br><span class="line">            border-collapse: collapse;</span><br><span class="line">            width:500px;</span><br><span class="line">            height: 300px;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>表格文字对齐</strong></p><p>表格中的水平对齐和垂直对齐属性</p><p>水平对齐</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-align: center;</span><br></pre></td></tr></table></figure><p>垂直对齐</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertical-align: top;</span><br></pre></td></tr></table></figure><p><strong>表格颜色</strong></p><p>下面的例子指定边框的颜色，th元素的文本和背景颜色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">table,td&#123;</span><br><span class="line">            border:3px solid red; </span><br><span class="line">        &#125;</span><br><span class="line"> td&#123;</span><br><span class="line">           text-align: center;</span><br><span class="line">           background-color: #555555;</span><br><span class="line">           color:#ffffff;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h2><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>选择所有被E包含的F元素，中间用空格隔开，对E的所有后代都生效</p><p>语法：<code>E F&#123;&#125;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">li</span>&gt;</span>子列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">li</span>&gt;</span>子列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ul li&#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h3><p>选择所有作为E的直接子元素F，对更深一层的元素不起作用，用&gt;表示</p><p>语法：<code>E&gt;F&#123;&#125;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&gt;p&#123;</span><br><span class="line">          color:red;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h3><p>选择紧跟E元素后的F元素，用加号表示，选择相邻的第一个兄弟元素,只能向下选择</p><p>语法：<code>E+F&#123;&#125;</code></p><h3 id="通用兄弟选择器"><a href="#通用兄弟选择器" class="headerlink" title="通用兄弟选择器"></a>通用兄弟选择器</h3><p>选择E元素之后的所有兄弟元素F，作用于多个元素，用<code>~</code>隔开,只能向下选择</p><p>语法：<code>E~F&#123;&#125;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h3~p&#123;</span><br><span class="line">        color:red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>元素0<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>元素1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>元素2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>盒子模型包含四个元素：</p><ul><li>Margin（外边距）：外边距是指元素与其它元素之间的距离。通过设置外边距，你可以控制元素与其它元素之间的间距。外边距会影响元素与其它元素的相对位置，但不会影响元素自身的尺寸。</li><li>Border（边框）：围绕在内边距和内容外的边框</li><li>Padding（内边距）：内边距是指元素内容与元素边框之间的距离。通过设置内边距，你可以增加元素内容与边框之间的空间。内边距会影响元素的尺寸和位置，但不会影响元素与其它元素之间的距离。</li><li>Content（内容）：盒子的内容，显示文本和图像</li></ul><h1 id="Svelte"><a href="#Svelte" class="headerlink" title="Svelte"></a>Svelte</h1><h2 id="创建一个svelte文件"><a href="#创建一个svelte文件" class="headerlink" title="创建一个svelte文件"></a>创建一个svelte文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx sveltejs/template filename</span><br><span class="line">cd filename</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>或者可以通过vite创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest</span><br></pre></td></tr></table></figure><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>在<code>&lt;script&gt;</code>标签内使用<code>let</code>创建变量和函数，并在外部使用{}使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">let</span> src = <span class="string">&#x27;tutorial/image.gif&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Rick Astley&#x27;</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;src&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;&#123;name&#125; dances.&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>将整个应用程序放在一个组件中是不切实际的，我们可以从其他文件导入组件并包含他们，其他组件可以视作子函数，APP.svelte为主函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//APP.svelte</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Nested from &#x27;./Nested.svelte&#x27;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">p &#123;</span><br><span class="line">color: purple;</span><br><span class="line">font-family: &#x27;Comic Sans MS&#x27;, cursive;</span><br><span class="line">font-size: 2em;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br><span class="line">&lt;Nested/&gt;</span><br><span class="line"></span><br><span class="line">//Nested.svelte</span><br><span class="line">&lt;p&gt;This is another paragraph.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>有时在<code>script</code>中定义的字符串有HTML的语法，我们需要将其直接绘制到组件中，此时需要使用**{@html…}**</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">`this string contains some &lt;strong&gt;HTML!!!&lt;/strong&gt;`</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;@html string&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="反应性能力"><a href="#反应性能力" class="headerlink" title="反应性能力"></a>反应性能力</h2><ul><li>反应性触发核心——赋值</li></ul><p>我们可以使用<code>$:</code>声明反应性的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let count = 0;</span><br><span class="line">  $: doubled = count * 2;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样当conut反生变化时，doubled也会跟着变化</p><p>我们也可以声明反应式的语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$: console.log(`the count is $&#123;count&#125;`)</span><br></pre></td></tr></table></figure><p>注意短短的一行代码有两个重点</p><ul><li>要在输出中输入变量，变量要加上${}，不然会被识别成字符而不是变量</li><li>输出语句使用**&#96;<strong>来包裹而不是单双引号，称为模板字符串，使用它可以在字符串中插入变量，表达式，配合</strong>${}**使用</li></ul><p>当然你也可以配合if使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$:if(count&gt;=10)&#123;</span><br><span class="line">        alert(`the count is $&#123;count&#125;`);</span><br><span class="line">        count=0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><font color="red">反应性由赋值语句触发</font>当使用数组的诸如<code>push</code>和<code>splice</code>之类的方法不会触发自动更新</p><p>解决该问题的方法可以添加一个多余的赋值语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">let numbers = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">function addNumber() &#123;</span><br><span class="line">numbers.push(numbers.length + 1);</span><br><span class="line">numbers=numbers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$: sum = numbers.reduce((t, n) =&gt; t + n, 0);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>更惯用的解决方案是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function addNumber() &#123;</span><br><span class="line">numbers = [...numbers, numbers.length + 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单的经验法则是，被更新的变量名必须出现在赋值语句的左侧</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>当我们需要将主组件的值传递给子组件时，我们需要在子组件内使用<code>export</code>来接收参数</p><p>使用 <code>&#123;&#125;</code> 将属性包裹起来传递给子组件。例如：<code>&lt;Child &#123;prop&#125; /&gt;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//APP.svelte</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Deliver from &#x27;./delivery.svelte&#x27;</span><br><span class="line">  let array=[1,2,3,4];</span><br><span class="line">  let num=5;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;Deliver &#123;array&#125; &#123;num&#125; /&gt;</span><br><span class="line"></span><br><span class="line">//delivery.svelte</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export let array;</span><br><span class="line">    export let num;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当传递一个对象属性时，我们可以使用<code>...</code>语法将他们传播到一个组件上</p><ul><li>注意声明对象属性的写法</li><li>子组件接收时需要用对象内的变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//APP.svelte</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Deliver from &#x27;./delivery.svelte&#x27;</span><br><span class="line">  const pkg=&#123;</span><br><span class="line">    name: &#x27;svelte&#x27;,</span><br><span class="line">    version: 3</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;Deliver &#123;...pkg&#125; /&gt; </span><br><span class="line"></span><br><span class="line">//delivery.svelte</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export let name;</span><br><span class="line">    export let version;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>if通过&#96;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/Clear1oveE/Clear1oveE.github.io/2023/09/25/git/"/>
      <url>/Clear1oveE/Clear1oveE.github.io/2023/09/25/git/</url>
      
        <content type="html"><![CDATA[<h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p><strong>配置个人的用户名称和电子邮箱地址：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;runoob&quot;</span><br><span class="line">$ git config --global user.email test@runoob.com</span><br></pre></td></tr></table></figure><p><strong>差异分析工具</strong></p><p>在解决合并冲突时使用哪种差异分析工具，如：vimdiff</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global merge.tool vimdiff</span><br></pre></td></tr></table></figure><p><strong>查看配置信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">//系统配置，可在（git/etc/gitconfig下找到）</span><br><span class="line">$ git config --system --list</span><br><span class="line">//用户配置，可在（C:\Users\谢承龙下找到）</span><br><span class="line">$ git config --global --list</span><br></pre></td></tr></table></figure><h1 id="基本的Linux命令"><a href="#基本的Linux命令" class="headerlink" title="基本的Linux命令"></a>基本的Linux命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cd 路径: 改变目录</span><br><span class="line">cd ..：回退到上一个目录</span><br><span class="line">pwd: 显示当前所在的目录路径</span><br><span class="line">clear：清屏</span><br><span class="line">ls（||）：列出当前目录的所有文件</span><br><span class="line">touch：新建一个文件 比如touch index.js会在当前目录下新建一个index.js文件</span><br><span class="line">rm：删除一个文件 如 rm index.js会把该文件删除</span><br><span class="line">mkdir：新建一个文件夹 如mkdir test会在当前目录下新建一个文件夹</span><br><span class="line">rm -r：删除一个文件夹，如rm -r test</span><br><span class="line">mv：移动文件 如mv index.html src     index.html是我们要移动的文件，src是目标文件夹</span><br><span class="line">history：查看命令历史</span><br><span class="line">exit：退出</span><br></pre></td></tr></table></figure><h1 id="Git基本理论"><a href="#Git基本理论" class="headerlink" title="Git基本理论"></a>Git基本理论</h1><blockquote><p>工作区域</p></blockquote><p>Git本地有三个工作区域，和远程的仓库，共四个工作区域：</p><ul><li>工作目录（Working Directory）</li><li>暂存区（Stage&#x2F;Index）</li><li>资源库（Repository或Git Directory）</li><li>远程我的git仓库（Remote Directory）</li></ul><p>文件在四个工作区域转换关系如下：</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Snipaste_2023-09-28_08-19-16.png"></p><ul><li>Workspace：工作区，平时以存放项目代码的地方</li><li>Index&#x2F;Stage：暂存区，用于临时存放你的改动，事实上它只是个文件，保存即将提交到文件列表的信息</li><li>Repository：本地仓库，安全存放数据的位置，这里有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库</li></ul><h1 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h1><p>创建本地仓库的方法有两种</p><ul><li>创建全新的仓库</li><li>克隆远程仓库</li></ul><blockquote><p>创建全新仓库</p></blockquote><p>初始化一个Git项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init//会在目标文件夹生成一个隐藏的git.文件夹</span><br></pre></td></tr></table></figure><blockquote><p>克隆远程仓库</p></blockquote><p>将远程服务器上的仓库完全镜像一份至本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone [url]</span><br><span class="line">//如$ git clone https://github.com/Clear1oveE/copy.github.io.git</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h1><blockquote><p>查看文件状态</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#查看指定文件状态</span><br><span class="line">git status[filaname]</span><br><span class="line"></span><br><span class="line">//查看所有文件状态</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add .                   //添加所有文件到暂存区</span><br><span class="line">git commit -m&quot;消息内容&quot;      //提交暂存区中的内容到本地仓库 -m 是提交的注释</span><br><span class="line">git push origin main       //将本地仓库推送到远程仓库的main分支</span><br></pre></td></tr></table></figure><blockquote><p>忽略文件</p></blockquote><p>有时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件等</p><p>在主目录下建立“.gitignore”文件，可以在里面配置不需要提交的文件。该文件有如下规则</p><ul><li>忽略文件中的空行或以#开始的行将被忽略</li><li>可以使用Linux通配符。例如：星号（*）任意多个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2}）代表可选的字符串等</li><li>如果名称的最前面有一个感叹号(!)，表示例外规则，将不被忽略</li><li>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录的文件不忽略</li><li>如果名称的最后面是一个路径分隔符(&#x2F;)，表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#为注释</span></span><br><span class="line">*.txt       <span class="comment">#忽略所有.txt结尾文件，这样的话上传就不会被选</span></span><br><span class="line">!lib.txt    <span class="comment">#但lib.txt除外</span></span><br><span class="line">/temp       <span class="comment">#仅忽略项目根目录下的TODO文件，不包括其他目录temp</span></span><br><span class="line">build/      <span class="comment">#忽略build/目录下的所有文件</span></span><br><span class="line">doc/*.txt   <span class="comment">#会忽略doc/notes.txt但不包括 doc/server/arch.txt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bin/: 忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件</span><br><span class="line">/bin: 忽略根目录下的bin文件</span><br><span class="line">/*.c: 忽略 cat.c，不忽略 build/cat.c</span><br><span class="line">debug/*.obj: 忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj</span><br><span class="line">**/foo: 忽略/foo, a/foo, a/b/foo等</span><br><span class="line">a/**/b: 忽略a/b, a/x/b, a/x/y/b等</span><br><span class="line">!/bin/run.sh: 不忽略 bin 目录下的 run.sh 文件</span><br><span class="line">*.<span class="built_in">log</span>: 忽略所有 .<span class="built_in">log</span> 文件</span><br><span class="line">config.php: 忽略当前路径的 config.php 文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="远程仓库的设置"><a href="#远程仓库的设置" class="headerlink" title="远程仓库的设置"></a>远程仓库的设置</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成公钥</span></span><br><span class="line">ssh -keygen -t rsa</span><br><span class="line"><span class="comment">#一直空格</span></span><br></pre></td></tr></table></figure><p>生成成功后可以通过：C:\Users\谢承龙.ssh 找到ssh公钥，并将其复制到远程仓库</p><h1 id="GIT分支"><a href="#GIT分支" class="headerlink" title="GIT分支"></a>GIT分支</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到新分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定仓库设置为upstream</span></span><br><span class="line">git remote add upstream [远程仓库的url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程仓库的指定分支拉取到当前分支</span></span><br><span class="line">git pull upstream main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除远程分支</span></span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="拉取远程仓库"><a href="#拉取远程仓库" class="headerlink" title="拉取远程仓库"></a>拉取远程仓库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个分支，并切换到新分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定仓库设置为upstream</span></span><br><span class="line">git remote add upstream [远程仓库的url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程仓库的指定分支拉取到当前分支</span></span><br><span class="line">git pull upstream main</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/Clear1oveE/Clear1oveE.github.io/2023/09/17/%E7%AE%97%E6%B3%95/"/>
      <url>/Clear1oveE/Clear1oveE.github.io/2023/09/17/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="多种排序"><a href="#多种排序" class="headerlink" title="多种排序"></a>多种排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>  将最左边的数设为基准数，分别从右边往左寻找比基准数小的数，从左往右寻找比基准数大的数，并交换位置，直到两数相遇，相遇位置与基准数互换，以此类推</p><ul><li>终止条件：left&gt;right</li><li>当left！&#x3D;right时一直循环</li><li>设置两个数从右往左找和从左往右找，先从右往左</li><li>找到时如果没有相遇，则交换位置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QuickSweep</span><span class="params">(<span class="type">int</span>* ary,<span class="type">int</span> left,<span class="type">int</span> right)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">QuickSweep(<span class="built_in">array</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSweep</span><span class="params">(<span class="type">int</span>* ary, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt; right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> temp = ary[left];</span><br><span class="line"><span class="type">int</span> moveR = right;</span><br><span class="line"><span class="type">int</span> moveL = left;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="keyword">while</span> (moveR != moveL) &#123;</span><br><span class="line"><span class="keyword">while</span> (ary[moveR] &gt;= temp &amp;&amp; moveR &gt; moveL)</span><br><span class="line">moveR--;</span><br><span class="line"><span class="keyword">while</span> (ary[moveL] &lt;= temp &amp;&amp; moveR &gt; moveL)</span><br><span class="line">moveL++;</span><br><span class="line"><span class="keyword">if</span> (moveL &lt; moveR) &#123;</span><br><span class="line">t = ary[moveL];</span><br><span class="line">ary[moveL] = ary[moveR];</span><br><span class="line">ary[moveR] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ary[left] = ary[moveR];</span><br><span class="line">ary[moveR] = temp;</span><br><span class="line"></span><br><span class="line">QuickSweep(ary, left, moveR - <span class="number">1</span>);</span><br><span class="line">QuickSweep(ary, moveR + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h1><p>  队列是一种特殊的线性结构，只允许在队列的首部（head）进行删除操作（出队），而在队列的尾部（tail）进行插入操作（入队），当没有元素时（head&#x3D;tail）称为空队列,是一种<strong>先进先出</strong>的数据结构</p><p>​      队列有三个基本元素（一个数组，两个变量），可以转为一个结构体类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queen</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> head;</span><br><span class="line"><span class="type">int</span> tail;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>​       栈则是一种<strong>后进后出</strong>的数据结构，限定为只能在一端进行插入和删除操作</p><p>​       栈有两个基本元素（一个数组，一个变量），同样可以转化为结构体类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>​    使用结构体，指针，malloc函数来生成链表，最优的一种是双向循环链表，能有效避免空指针的问题，在插入和删除时也能更加从容</p><ul><li>要保存head的地址</li><li>结构体中有next和pre，分别用来储存下一个节点和上一个节点的地址</li><li>最后一个节点的next指向head，head的pre指向最后一个节点</li><li>head不储存数据</li></ul><p>完整链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linklist</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linklist</span>* <span class="title">next</span>;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linklist</span>* <span class="title">pre</span>;</span></span><br><span class="line">&#125;linkList;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitHead</span><span class="params">(linkList**)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(linkList*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetLength</span><span class="params">(linkList*)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Add</span><span class="params">(linkList*)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete</span><span class="params">(linkList*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(linkList*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(linkList**)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">linkList* head=<span class="literal">NULL</span>;</span><br><span class="line">InitHead(&amp;head);</span><br><span class="line">Insert(head);</span><br><span class="line"><span class="type">int</span> l=GetLength(head);</span><br><span class="line"><span class="keyword">if</span> (Add(head)) &#123;</span><br><span class="line">Print(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Delete(head)) &#123;</span><br><span class="line">Print(head);</span><br><span class="line">&#125;</span><br><span class="line">DestroyList(&amp;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitHead</span><span class="params">(linkList**head)</span> &#123;</span><br><span class="line">linkList* <span class="built_in">list</span> = (linkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linkList));</span><br><span class="line"><span class="built_in">list</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">list</span>-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">*head = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(linkList*head)</span> &#123;</span><br><span class="line">linkList* cur=<span class="literal">NULL</span>;</span><br><span class="line">linkList* <span class="built_in">list</span> = head;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;n)&amp;&amp;n != <span class="number">-1</span>) &#123;</span><br><span class="line">cur = (linkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linkList));</span><br><span class="line">cur-&gt;data = n;</span><br><span class="line">cur-&gt;pre = <span class="built_in">list</span>;</span><br><span class="line">cur-&gt;next = head;</span><br><span class="line"><span class="built_in">list</span>-&gt;next = cur;</span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">head-&gt;pre = cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetLength</span><span class="params">(linkList* head)</span> &#123;</span><br><span class="line">linkList* <span class="built_in">list</span>=<span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span> = head-&gt;next; <span class="built_in">list</span> != head; <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next) &#123;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Add</span><span class="params">(linkList*head)</span> &#123;</span><br><span class="line"><span class="type">int</span> ele, pos;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入你想插入的元素和位置&quot;</span>);</span><br><span class="line">scanf_s(<span class="string">&quot;%d%d&quot;</span> ,&amp;ele, &amp;pos);</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">linkList* <span class="built_in">list</span> = head;</span><br><span class="line"><span class="keyword">while</span> (j &lt; pos - <span class="number">1</span> &amp;&amp; <span class="built_in">list</span> != head-&gt;pre) &#123;</span><br><span class="line">j++;</span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; pos - <span class="number">1</span> || <span class="built_in">list</span> == head-&gt;pre)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">linkList* tem = <span class="literal">NULL</span>;</span><br><span class="line">tem = (linkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linkList));</span><br><span class="line"><span class="keyword">if</span> (!tem)<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">tem-&gt;data = ele;</span><br><span class="line">tem-&gt;next = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"><span class="built_in">list</span>-&gt;next = tem;</span><br><span class="line">tem-&gt;pre = <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Delete</span><span class="params">(linkList*head)</span> &#123;</span><br><span class="line"><span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入想要删除的节点&quot;</span>);</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;pos);</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">linkList* <span class="built_in">list</span>=head;</span><br><span class="line">linkList* target = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; pos - <span class="number">1</span> &amp;&amp; <span class="built_in">list</span> != head-&gt;pre) &#123;</span><br><span class="line">j++;</span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; pos - <span class="number">1</span> || <span class="built_in">list</span> == head-&gt;pre)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">target = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"><span class="built_in">list</span>-&gt;next = target-&gt;next;</span><br><span class="line">target-&gt;next-&gt;pre = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">free</span>(target);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(linkList*head)</span> &#123;</span><br><span class="line">linkList* <span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span> = head-&gt;next; <span class="built_in">list</span> != head; <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span> -&gt; data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(linkList**head)</span> &#123;</span><br><span class="line">linkList *<span class="built_in">list</span>=*head;</span><br><span class="line">linkList* cur = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">linkList* delet=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (cur != *head) &#123;</span><br><span class="line">delet = cur;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(delet);</span><br><span class="line">&#125;</span><br><span class="line">*head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="深度优先搜索（dfs）"><a href="#深度优先搜索（dfs）" class="headerlink" title="深度优先搜索（dfs）"></a>深度优先搜索（dfs）</h1><ul><li>关键在于解决“当下该如何做”和“下一步如何做”</li></ul><p>主要思想：</p><ul><li>首先以一个未访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点</li><li>当没有未访问过的顶点时，则回到上一个顶点，继续试探访问别的顶点，直到所有顶点都被访问过</li><li>显然，dfs是沿着图的某一条分支遍历直到末端，然后回溯，再沿着另一条路径进行同样的遍历</li></ul><p>基本模型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x，<span class="type">int</span> y,<span class="type">int</span> step)</span>&#123;</span><br><span class="line">判断边界终止递归（可能没有边界）</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    尝试每一种可能 <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        tx=x+?;</span><br><span class="line">        ty=y+?;</span><br><span class="line">        判断是否越界;</span><br><span class="line">        标记;</span><br><span class="line">        继续下一步dfs(tx,ty,step+<span class="number">1</span>);</span><br><span class="line">        取消标记（可有可没有，按情况考虑）;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span>[<span class="number">6</span>][<span class="number">6</span>], <span class="type">int</span>[<span class="number">6</span>][<span class="number">6</span>], <span class="type">int</span>*, <span class="type">int</span>, <span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> act[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> trace[<span class="number">6</span>][<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> max[<span class="number">1</span>];</span><br><span class="line">max[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++) &#123;</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">trace[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">Find(<span class="built_in">map</span>, trace, max, <span class="number">1</span>, <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;最小路径是%d&quot;</span>, max[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">6</span>], <span class="type">int</span> trace[<span class="number">6</span>][<span class="number">6</span>], <span class="type">int</span>*max, <span class="type">int</span> x, <span class="type">int</span> y,<span class="type">int</span> count)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>[x][y] == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(max[<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">max[<span class="number">0</span>] = count;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (count &lt; max[<span class="number">0</span>])</span><br><span class="line">max[<span class="number">0</span>] = count;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> tx = x + act[i][<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> ty = y + act[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tx &gt;= <span class="number">1</span> &amp;&amp; tx &lt;= <span class="number">5</span> &amp;&amp; ty &gt;= <span class="number">1</span> &amp;&amp; ty &lt;= <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (trace[tx][ty] != <span class="number">1</span> &amp;&amp; <span class="built_in">map</span>[tx][ty] != <span class="number">1</span>) &#123;</span><br><span class="line">trace[tx][ty] = <span class="number">1</span>;</span><br><span class="line">Find(<span class="built_in">map</span>, trace, max, tx, ty, count+<span class="number">1</span>);</span><br><span class="line">trace[tx][ty] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul><li>在模拟人物在二维数组内移动时，可将人物的移动(即每次移动x，y坐标的变化)存入数组，这样会方便for循环遍历任务的移动</li></ul><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> act[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><h1 id="广度优先搜索（bfs）"><a href="#广度优先搜索（bfs）" class="headerlink" title="广度优先搜索（bfs）"></a>广度优先搜索（bfs）</h1><p>​        层层递进，将所有点放在一个线性表中，每次进行移动都将移动后的点加入线性表，并使tail++，在遍历完四个方向后，使head++</p><ul><li>需要一个结构体</li><li>需要一个存放每一个节点的线性表（结构体数组）</li><li>需要head和tail</li></ul><p>主要思想：</p><ul><li>以一个未被访问过的顶点作为起始顶点，访问所有相邻顶点</li><li>然后对每个相邻的顶点，再访问他们相邻的未被访问过的顶点</li></ul><p>基本模型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace</span> &#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="type">int</span> f;</span><br><span class="line"><span class="type">int</span> s;</span><br><span class="line">&#125;trace;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> head=<span class="number">1</span>,tail=<span class="number">2</span>;</span><br><span class="line">    trace t[];</span><br><span class="line">    t[head].x=?;</span><br><span class="line">    t[head].y=?;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tx,ty;</span><br><span class="line">    <span class="keyword">while</span>(head&lt;tail)&#123;</span><br><span class="line">       尝试每一种可能 <span class="keyword">for</span>()</span><br><span class="line">       &#123;</span><br><span class="line">            tx=t[head].x+?;</span><br><span class="line">        判断边界;</span><br><span class="line">        <span class="keyword">if</span>(满足条件的点)</span><br><span class="line">        &#123;</span><br><span class="line">            存入tail中</span><br><span class="line">            t[tail].x=tx;</span><br><span class="line">            标记;</span><br><span class="line">            tail++;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       head++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace</span> &#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="type">int</span> f;</span><br><span class="line"><span class="type">int</span> s;</span><br><span class="line">&#125;trace;</span><br><span class="line"><span class="type">int</span> act[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitMap</span><span class="params">(<span class="type">int</span>[][<span class="number">50</span>],<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitPosition</span><span class="params">(trace*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">FindMin</span><span class="params">(trace*,<span class="type">int</span>[][<span class="number">50</span>], <span class="type">int</span>[][<span class="number">50</span>], <span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> head, <span class="type">int</span> tail,<span class="type">int</span> ,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="type">int</span>,trace*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> book[<span class="number">50</span>][<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">trace t[<span class="number">2500</span>];</span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> p, q;</span><br><span class="line"><span class="type">int</span> head = <span class="number">1</span>, tail = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> w, l;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入地图的长和宽：&quot;</span>);</span><br><span class="line">scanf_s(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;w);</span><br><span class="line">InitMap(<span class="built_in">map</span>,l,w);</span><br><span class="line">InitPosition(t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入目标地点：&quot;</span>);</span><br><span class="line">scanf_s(<span class="string">&quot;%d%d&quot;</span>, &amp;p, &amp;q);</span><br><span class="line">Print(FindMin(t, book, <span class="built_in">map</span>, p, q, head, tail, l, w),t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitMap</span><span class="params">(<span class="type">int</span> <span class="built_in">map</span>[][<span class="number">50</span>],<span class="type">int</span> l,<span class="type">int</span> w)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入地图&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= l; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= w; j++)</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitPosition</span><span class="params">(trace *trace)</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入初始坐标:&quot;</span>);</span><br><span class="line">scanf_s(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">trace[<span class="number">1</span>].x = x;</span><br><span class="line">trace[<span class="number">1</span>].y = y;</span><br><span class="line">trace[<span class="number">1</span>].f = <span class="number">0</span>;</span><br><span class="line">trace[<span class="number">1</span>].s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">FindMin</span><span class="params">(trace*trace, <span class="type">int</span> book[][<span class="number">50</span>], <span class="type">int</span> <span class="built_in">map</span>[][<span class="number">50</span>], <span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> head, <span class="type">int</span> tail,<span class="type">int</span> l,<span class="type">int</span> w)</span> &#123;</span><br><span class="line"><span class="type">int</span> tx, ty;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">tx = trace[head].x + act[i][<span class="number">0</span>];</span><br><span class="line">ty = trace[head].y + act[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (tx&lt;<span class="number">1</span> || tx&gt;w || ty&lt;<span class="number">1</span> || ty&gt;l)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>[tx][ty] == <span class="number">0</span> &amp;&amp; book[tx][ty] == <span class="number">0</span>) &#123;</span><br><span class="line">trace[tail].x = tx;</span><br><span class="line">trace[tail].y = ty;</span><br><span class="line">trace[tail].f = head;</span><br><span class="line">trace[tail].s = trace[head].s + <span class="number">1</span>;</span><br><span class="line">book[tx][ty] = <span class="number">1</span>;</span><br><span class="line">tail++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tx == p &amp;&amp; ty == q)</span><br><span class="line"><span class="keyword">return</span> tail<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">head++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="type">int</span> tail, trace*t)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t[tail].s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h1>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学</title>
      <link href="/Clear1oveE/Clear1oveE.github.io/2023/09/15/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
      <url>/Clear1oveE/Clear1oveE.github.io/2023/09/15/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'],['\\(','\\)']]} }); </script> <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script><h1 id="9-1-Relations-and-their-properties"><a href="#9-1-Relations-and-their-properties" class="headerlink" title="9.1 Relations and their properties"></a>9.1 Relations and their properties</h1><h2 id="Cartesian-product-笛卡尔乘积"><a href="#Cartesian-product-笛卡尔乘积" class="headerlink" title="Cartesian product(笛卡尔乘积)"></a>Cartesian product(笛卡尔乘积)</h2><p>If A and B are two nonempty sets</p><p>$$A\times B&#x3D;{(a,b)|a \in A \quad and \quad b \in B}$$</p><h2 id="Partition-划分-or-quotient-set（商集）"><a href="#Partition-划分-or-quotient-set（商集）" class="headerlink" title="Partition(划分)or quotient set（商集）"></a>Partition(划分)or quotient set（商集）</h2><ul><li>A<del>1</del>和A<del>2</del>是P种不同的子集，那么<strong>A<del>1</del>$\cap$A<del>2</del>&#x3D;$\emptyset$</strong></li><li>A的所有划分后的子集和就是A</li></ul><h2 id="Relation"><a href="#Relation" class="headerlink" title="Relation"></a>Relation</h2><p><strong>Definition：</strong> Let <em>A</em> and <em>B</em> be nonempty sets. A <font color="red">relation R from A to B</font> is a subset of <em>A</em> $\times$B</p><ul><li><p>If <em>R</em> $\subseteq$ <em>A</em> $\times$<em>B</em> and (<em>a</em>, <em>b</em>)$\in$ <em>R</em>, we say that <font color="red"><em>a</em> is related to <em>b</em> by <em>R</em></font>, and we also write <font color="red"><em>a</em> <em>R</em> <em>b</em></font>.</p></li><li><p>If <em>a</em> is not related to <em>b</em> by <em>R</em>, we write <em>a</em> <em>R&#x2F;</em> <em>b</em>.</p></li><li><p>R$\subseteq$A$\times$A is a relation on A</p></li></ul><p>eg:</p><p>​     Let|A|&#x3D;n,How many relations are there on a set A?    -&gt;   <font color="red">2<sup>n<sup>2</sup></sup></font></p><p>​    <font color="blue">解析</font>:A有n个基数，A$\times$A的集合中就有n^2^个基数，那么就有 <font color="red">2<sup>n<sup>2</sup></sup></font>种子集，每一种子集就代表一种关系</p><p>Dom(<em>R</em>), the <em>domain</em> of <em>R</em> is a subset of <em>A</em>, is the set of all first elements in the pairs that make up <em>R</em></p><p>Ran(<em>R</em>), the <em>range</em> of <em>R</em> is the set of elements in <em>B</em> that are second elements of pairs in <em>R.</em></p><h3 id="R-relative-set"><a href="#R-relative-set" class="headerlink" title="R-relative set"></a>R-relative set</h3><p>If <em>R</em> is a relation from <em>A</em> to <em>B</em> and <em>x</em>$\in$ <em>A</em>.</p><p>Define <em>R</em>(<em>x</em>), the <strong>R-relative set of x</strong>, to be the set of <font color="red">all <em>y</em> in <em>B</em> with the property that <em>x</em> is <em>R</em>-related to <em>y</em>.</font><br>$$<br>R(x)&#x3D;{y \in B|x R  y}<br>$$<br>Similarly, if <em>A</em><del>1</del>$\subseteq$ <em>A</em>, then <em>R</em>(<em>A</em><del>1</del>), the <em>R-relative set of A</em><del>1</del>, is the set of all <em>y</em> in <em>B</em> with the property that <em>x</em> is <em>R</em>-related to <em>y</em> for some <em>x</em> in <em>A</em><del>1</del>.<br>$$<br>R(x)&#x3D;{y \in B|x R  y\quad for\quad some \quad x\quad in \quad A<del>1</del>}<br>$$</p><h4 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h4><ul><li>*<em>If <em>A</em>1 $\subseteq$<em>A</em>2, then <em>R</em>(<em>A1</em>) $\subseteq$ <em>R</em>(<em>A</em>2)</em>*</li><li>*<em>R(<em>A1</em>$\cup$ <em>A</em>2) &#x3D; <em>R</em>(<em>A</em>1) $\cap$ <em>R</em>(<em>A</em>2)</em>*</li><li>*<em>R(<em>A</em>1 $\cup$<em>A</em>2) &#x3D;<em>R</em>(<em>A</em>1) $\cup$ <em>R</em>(<em>A</em>2)</em>*</li></ul><h3 id="Special-properties"><a href="#Special-properties" class="headerlink" title="Special properties"></a>Special properties</h3><h4 id="Reflexive-自反-and-Irreflexive（反自反）"><a href="#Reflexive-自反-and-Irreflexive（反自反）" class="headerlink" title="Reflexive(自反) and Irreflexive（反自反）"></a>Reflexive(自反) and Irreflexive（反自反）</h4><h5 id="re-自反"><a href="#re-自反" class="headerlink" title="[re]自反"></a>[re]自反</h5><p><strong>Definition</strong>:对每个元素a$\in$A有（a，a）$\in$R,那么定义在集合A上的<font color="red">关系R称为自反的</font></p><p>R is reflexive iff<br>$$<br>\forall x[x\in A-&gt;(x,x)\in R]<br>$$</p><h5 id="ir-反自反"><a href="#ir-反自反" class="headerlink" title="[ir]反自反"></a>[ir]反自反</h5><p><em>R</em> is <em>irreflexive</em> iff<br>$$<br>\forall x[x\in A-&gt;(x,x)\notin R]<br>$$</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-15_19-30-00.png"></p><h4 id="Symmetric（对称），Asymmetric（非对称），and-Antisymmetric（反对称）"><a href="#Symmetric（对称），Asymmetric（非对称），and-Antisymmetric（反对称）" class="headerlink" title="Symmetric（对称），Asymmetric（非对称），and Antisymmetric（反对称）"></a>Symmetric（对称），Asymmetric（非对称），and Antisymmetric（反对称）</h4><h5 id="Sy-对称"><a href="#Sy-对称" class="headerlink" title="[Sy]对称"></a>[Sy]对称</h5><p><strong>Definition</strong>:对于任意（a,b)$\in$A，若只要（a，b）$\in$R,就有（b，a）$\in$R,则称定义在集合A上的关系R是对称的</p><p>R is <em>Asymmetric</em> iff<br>$$<br>\forall x\forall y[( x, y ) \in R-&gt; (y, x ) \in R]<br>$$</p><h5 id="As-非对称"><a href="#As-非对称" class="headerlink" title="[As]非对称"></a>[As]非对称</h5><p>R is <em>Asymmetric</em> iff<br>$$<br>\forall x\forall y[( x, y ) \in R-&gt; (y, x ) \notin R]<br>$$</p><h5 id="Ats-反对称"><a href="#Ats-反对称" class="headerlink" title="[Ats]反对称"></a>[Ats]反对称</h5><p><strong>Definition</strong>:不存在由不同元素a和b构成的有序对，是的a与b有关系，并且b与a也有关系，也就是说，唯一一种a与b有关系并且b与a有关系的情况是a和b是相同的元素</p><p><em>R</em> is <em>antisymmetric</em> iff<br>$$<br>\forall x\forall y[( x, y ) \in R \wedge(y,x)\in R-&gt; x&#x3D;y]<br>$$<br><strong>Note</strong>：</p><ul><li>对称与反对称概念不是对立的，一个关系可以同时有这两种性质或者这两种性质都没有</li></ul><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-15_19-43-37.png"></p><h4 id="Transitive（传递）"><a href="#Transitive（传递）" class="headerlink" title="Transitive（传递）"></a>Transitive（传递）</h4><h5 id="tr-传递"><a href="#tr-传递" class="headerlink" title="[tr]传递"></a>[tr]传递</h5><p><em>R</em> is <em>transitive</em> iff<br>$$<br>\forall x\forall y\forall z[( x, y ) \in R \wedge ( y, z ) \in R-&gt; ( x, z ) \in R]<br>$$</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-15_19-45-55.png"></p><h4 id="Composition-合成"><a href="#Composition-合成" class="headerlink" title="Composition(合成)"></a>Composition(合成)</h4><p><strong>Definition</strong>： R是集合A到集合B的关系，S是集合B到集合C的关系。R与S的合成是有序对（a,c）的集合构成的关系，a$\in$A,c$\in$C,存在一个b$\in$B的元素，使得(a,b)$\in$S,我们用S$\circ$R表示R与S的合成</p><h5 id="n元素各种关系的数目"><a href="#n元素各种关系的数目" class="headerlink" title="n元素各种关系的数目"></a>n元素各种关系的数目</h5><p><a href="https://blog.csdn.net/zsdoujiang/article/details/105151135"></a></p><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><ul><li>当关系是对称时，，同时存在（a,c）,(c,a)，此时在关注传递性时，要注意必须（a,a）,(c,c)存在时，即a，c自反时才是可传递的</li></ul><h5 id="关系的幂"><a href="#关系的幂" class="headerlink" title="关系的幂"></a>关系的幂</h5><p><strong>Definition</strong>： $R^1$&#x3D;$R$,$R^{n+1}&#x3D;&#x3D;&#x3D;$&#x3D;$R^n$ $\circ$$R$</p><p><strong>Theorem</strong></p><ul><li>集合A上的关系R是传递的，当且仅当n&#x3D;1,2,3…有$R^n$$\subseteq$$R$</li></ul><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-15_20-13-37.png"></p><h1 id="9-2-N-ary-Relations"><a href="#9-2-N-ary-Relations" class="headerlink" title="9.2 N-ary Relations"></a>9.2 N-ary Relations</h1><h2 id="n-ary-relation"><a href="#n-ary-relation" class="headerlink" title="n-ary relation"></a>n-ary relation</h2><p><strong>Definition</strong>:A1,A2,A3…是集合，定义在这些集合上的n元关系是A1$\times$A2$\times$A3…$\times$An的子集。这些集合A1，A2，A3…称为关系的<strong>domains（域）</strong>，n称为关系的<strong>degree（阶）</strong></p><h2 id="Relational-database"><a href="#Relational-database" class="headerlink" title="Relational database"></a>Relational database</h2><p>​       当n元组的某个<strong>域</strong>的值能确定这个n元组时，n元关系的这个这个域就叫作<strong>主键（primary key）</strong>。也就是说，当关系中没有两个n元组在这个域有相同的值时，这个域就是<strong>主键</strong></p><p>​        在一个n元关系中，域的组合也可以唯一地标识n元组。当一组域的值确定一个关系中的n元组时，这些域的笛卡尔乘积就叫作<strong>复合主键（composite key）</strong></p><p><strong>tips</strong>：</p><ul><li><em>n</em>-tuples（n元组）</li></ul><h2 id="Selection-operator（选择运算符）"><a href="#Selection-operator（选择运算符）" class="headerlink" title="Selection operator（选择运算符）"></a>Selection operator（选择运算符）</h2><p><strong>Definition</strong>： R是一个n元关系，C是R中元素可能满足的一个条件。那么选择运算符s<del>c</del>将n元关系R映射到R中满足条件C的所有n元组构成的n元关系</p><p>Let <em>A</em> be any <em>n</em>-ary domain <em>A</em>&#x3D;<em>A</em>1×…×<em>An</em>, and let <em>C</em>:<em>A</em>→{<strong>T</strong>,<strong>F</strong>}<br>$$<br>\forall R\subseteq A, sc(R) &#x3D; {a\in R | sc(a) &#x3D; T}<br>$$</p><h2 id="Projection-operator-投影"><a href="#Projection-operator-投影" class="headerlink" title="Projection operator(投影)"></a>Projection operator(投影)</h2><p><strong>Definition</strong>： 投影$P_{i1，i2…im}$，删去n元组的n-m个分量，保留i1，i2…im个分量</p><h2 id="Join-operator（连接）"><a href="#Join-operator（连接）" class="headerlink" title="Join operator（连接）"></a>Join operator（连接）</h2><p>当两个表有某些相同的域时，连接运算可将这两个表合成一个表</p><h1 id="9-3-Representing-relations"><a href="#9-3-Representing-relations" class="headerlink" title="9.3 Representing relations"></a>9.3 Representing relations</h1><h2 id="The-matrix-of-a-relation（矩阵表示关系）"><a href="#The-matrix-of-a-relation（矩阵表示关系）" class="headerlink" title="The matrix of a relation（矩阵表示关系）"></a>The matrix of a relation（矩阵表示关系）</h2><p>关系R可以用矩阵M<del>R</del>&#x3D;[m<del>ij</del>]来表示，其中<br>$$<br>mij&#x3D;\begin{cases} 1,(ai,bj)\in R\ 0, (ai,bj)\notin R\end{cases}<br>$$</p><p>换句话说，ai和bj有关系时表示R的0-1矩阵的（i，j）项是1，没关系时是0</p><p>可以用0-1矩阵表示特殊关系</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-15_21-24-45.png"></p><h3 id="Combining-connection-matrices"><a href="#Combining-connection-matrices" class="headerlink" title="Combining connection matrices"></a>Combining connection matrices</h3><ul><li>MR1$\cup$R2&#x3D;M<del>R1</del>$\vee$R<del>2</del></li><li>MR1$\cap$R2&#x3D;M<del>R1</del>$\wedge$M<del>R2</del></li></ul><h3 id="Composite-of-relations"><a href="#Composite-of-relations" class="headerlink" title="Composite of relations"></a>Composite of relations</h3><p>通过布尔积得到<br>$$<br>M_S ◦_R &#x3D; M_R ⊙M_S.<br>$$</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-15_21-36-35.png"></p><h2 id="The-digraph-of-a-relation-用图表示关系"><a href="#The-digraph-of-a-relation-用图表示关系" class="headerlink" title="The digraph of a relation(用图表示关系)"></a>The digraph of a relation(用图表示关系)</h2><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-15_21-39-53.png"></p><p><strong>in-degree</strong>: 根据图表来看有多少箭头指向目标(看目标的列有多少个1)</p><p><strong>out-degree</strong>:根据图标来看有多少箭头从目标发出（看目标行有多少个1）</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-15_21-43-54.png"></p><h3 id="用图表表示特殊关系"><a href="#用图表表示特殊关系" class="headerlink" title="用图表表示特殊关系"></a>用图表表示特殊关系</h3><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-15_21-48-15.png"></p><h2 id="Restriction"><a href="#Restriction" class="headerlink" title="Restriction"></a>Restriction</h2><p><strong>Definition</strong>: If <em>R</em> is a relation on a set <em>A</em>, and <em>B</em> is a subset of <em>A</em>, the <em>restriction of R to B</em> is<br>$$<br>R \cap (B \times B)<br>$$</p><h1 id="9-4-关系的闭包-Closures-of-relation"><a href="#9-4-关系的闭包-Closures-of-relation" class="headerlink" title="9.4 关系的闭包(Closures of relation)"></a>9.4 关系的闭包(Closures of relation)</h1><p>​        定义：设R 是集合A 上的关系，如果存在包含R的具有性质P的关系S,并且S是所有包含R且具有性质P的子集（即S是包含关系R的最小的关系），那么S称为R关于性质P的闭包。</p><ul><li>自反闭包（reflexive closure）:r(R)</li><li>对称闭包（symmetric closure）:s(R)</li><li>传递闭包（transitive) :t(R)</li></ul><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-21_00-48-07.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-21_00-50-53.png"></p><h2 id="有向图的路径-paths"><a href="#有向图的路径-paths" class="headerlink" title="有向图的路径(paths)"></a>有向图的路径(paths)</h2><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-21_00-56-17.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-21_00-56-17.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-21_01-01-42.png"></p><p>​        R^n^:R是集合A上的关系。从a到b存在一条长为n的路径（即找出所有两点相距路径为2的a，b两点并连线）</p><p>​        R*:连通性关系由形如（a，b）的有序对构成，使得在关系R中，从顶点a到b之间存在一条长度至少为1的路径（找出所有路径至少为1的两点并连线）</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-21_01-16-18.png"><br>$$<br>M_{R^2}&#x3D;M_R\odot M_R&#x3D;(M_R)^2 \<br>M_{R^n}&#x3D;M_R\odot M_R…\odot M_R&#x3D;(M_R)^n_\odot<br>$$</p><ul><li>关系R的传递闭包等于连通性关系R*</li></ul><p>​        求R的传递闭包可用的方法</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-21_13-06-29.png"></p><h2 id="Warshall算法"><a href="#Warshall算法" class="headerlink" title="Warshall算法"></a>Warshall算法</h2><ol><li>找到矩阵对角线，并从对角线的左上方开始为第一个元素</li><li>以对角线上第一个元素为中心，<font color="red">按列展开</font>,寻找中心所在的<strong>列</strong>中所有<strong>不为零的元素</strong></li><li>将该中心<font color="red">所在行</font>加到该中心所在的列中<font color="red">所有不为0的元素所在的列上</font></li><li>加完之后，以对角线上第二个元素为中心，按列展开，重复操作3</li><li>一直将对角线上的所有元素都展开后结束</li></ol><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-09-21_21-17-07.png"></p><h1 id="9-5-等价关系（equivalence-relation）"><a href="#9-5-等价关系（equivalence-relation）" class="headerlink" title="9.5 等价关系（equivalence relation）"></a>9.5 等价关系（equivalence relation）</h1><p>​       定义：只有定义在A上的关系R<strong>同时是自反，对称和传递的</strong>，称为等价关系</p><p>​      eg:R是定义在整数集上的关系，满足aRb当且仅当a&#x3D;b或a&#x3D;-b，R是自反的，对称的和传递的。因此R是等价关系</p><h2 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h2><p>​      定义：设R是定义在集合A上的等价关系。与A中的一个元素a有关系的所有元素的 集合叫做a的等价类。A的关于R的等价类记作$[a]_R$，当只考虑一个关系时,我们将省去下标R并把这个等价类写作[a]</p><p>​        换言之，如果R是定义在集合A上的等价关系，则元素a的等价类是<br>$$<br>[a]_R&#x3D;{s|(a,s)\in R}<br>$$<br>如果$b\in[a]_R$,b叫做这个等价类的代表元</p><h1 id="9-6-偏序（partial-orderings）"><a href="#9-6-偏序（partial-orderings）" class="headerlink" title="9.6 偏序（partial orderings）"></a>9.6 偏序（partial orderings）</h1><h2 id="偏序（partial-order）"><a href="#偏序（partial-order）" class="headerlink" title="偏序（partial order）"></a>偏序（partial order）</h2><p>​        定义：定义在集合S上的关系R，如果他是<strong>自反</strong>的，<strong>反对称</strong>的和<strong>传递</strong>的，就称为偏序</p><p>​        偏序集（partial order set or poset）：集合S与定义在其上的偏序R一起称为<strong>偏序集（partially ordered set）或poset</strong>，记作（S，R）</p><h2 id="线序关系（linear-order-）"><a href="#线序关系（linear-order-）" class="headerlink" title="线序关系（linear order ）"></a>线序关系（linear order ）</h2><p>​      <font color="red">偏序集</font>（S，&lt;&#x3D;）中的元素a和b称为<strong>可比(comparable)<strong>的，如果有a&lt;&#x3D;b或b&lt;&#x3D;a，如果既没有a&lt;&#x3D;b又没有b&lt;&#x3D;a，则称a与b</strong>不可比(incomparable)</strong></p><p>​        如果(S,&lt;&#x3D;)是偏序集，且S中的每对元素都是可比的，则S称为<strong>全序集或线序集（linearly ordered set）</strong>，且&lt;&#x3D;称为<strong>全序或线序（linear order）</strong>。一个全序集也称为<strong>链(chain)</strong></p><p>eg:</p><p>​       偏序集（$Z^+$,|）中3和9可比，3|9，但5和7不可比,5&#x2F;|7，所以不是全序集</p><p>​        而（$Z^+$,&lt;&#x3D;）是全序集</p><p>​        对于偏序集（S，&lt;&#x3D;），如果&lt;&#x3D;是全序，那么S的每个非空子集都有一个最小元素，就称他为<strong>良序集（well-ordered set）</strong></p><p>eg：</p><p>​       集合Z与通常的&lt;&#x3D;不是良序的，因为负整数集合是Z的集合，但没有最小元素</p><p>良序归纳定理：</p><p>​       设S是一个良序集。如果对所有$y\in S$,如果P(x)对所有$x\in S$且x&lt;y为真，则P（y）为真，那么P(x)对所有的$x\in S$为真</p><h2 id="拟序关系（quasiorder）"><a href="#拟序关系（quasiorder）" class="headerlink" title="拟序关系（quasiorder）"></a>拟序关系（quasiorder）</h2><p>​       定义在集合A上的关系R，如果是<strong>传递和反自反</strong>的，那么称为拟序关系</p><p>eg:<br>(P(S),$\subset$)</p><h2 id="乘积偏序（product-partial-order）"><a href="#乘积偏序（product-partial-order）" class="headerlink" title="乘积偏序（product partial order）"></a>乘积偏序（product partial order）</h2><p>​        如果（A，&lt;&#x3D;）和（B,&lt;&#x3D;）都是偏序集，那么（A*B，&lt;&#x3D;）也是偏序集</p><h2 id="词典顺序（lexicographic-order）"><a href="#词典顺序（lexicographic-order）" class="headerlink" title="词典顺序（lexicographic order）"></a>词典顺序（lexicographic order）</h2><p>​        在两个偏序集的笛卡尔乘积上构造一个偏序。在A1*A2上的**词典顺序&lt;&#x3D;**定义如下：</p><p>​       如果一个有序对的第一个元素小于第二个有序对的第一个元素，或者第一个元素相等，但是第一个有序对的第二个元素小于第二个有序对的第二个元素，那么第一个有序对小于第二个有序对</p><h2 id="哈斯图（hasse-diagrams）"><a href="#哈斯图（hasse-diagrams）" class="headerlink" title="哈斯图（hasse diagrams）"></a>哈斯图（hasse diagrams）</h2><p>哈斯图是定义在有穷偏序集的有向图中：</p><ul><li>删除所有自反关系画出的环</li><li>删除所有因为传递关系而出现的边，如x&lt;y,y&lt;z则移走所有如(x,y)的边</li><li>排列每条边使得他的起点在终点的下面，并删除所有的箭头</li></ul><p><font color="red"><strong>tips</strong></font>:</p><ul><li>P({a,b,c})表示{a,b,c}的所有幂集，P({a, b, c}) &#x3D; {∅, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, {a, b, c}}</li></ul><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-03_21-37-48.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-04_09-11-40.png"></p><h2 id="极大元-maximal-element-与极小元-minimal-element"><a href="#极大元-maximal-element-与极小元-minimal-element" class="headerlink" title="极大元(maximal element)与极小元(minimal element)"></a>极大元(maximal element)与极小元(minimal element)</h2><ul><li>极大元(maximal element)：当偏序集中的一个元素<strong>不小于</strong>这个偏序集中的其它元素</li><li>极小元(minimal element)：当偏序集中的一个元素<strong>不大于</strong>这个偏序集中的其它元素</li><li>最大元(greatest element)：偏序集存在一个元素<strong>大于</strong>其他的元素</li><li>最小元(least element)：偏序集存在一个元素<strong>小于</strong>其他的元素</li></ul><p>tips：</p><ul><li>使用哈塞图很容易识别极大元和极小元，他们是图中的顶元素和底元素</li><li>一个偏序集中可以有多个极大元和极小元</li><li>偏序集中不一定有最大元和最小元</li></ul><p>eg：</p><p>在偏序集（$Z^+$,|）是否存在最大元和最小元？</p><p>​       1是最小元，因为只要n是正整数，就有1|n。因为没有被所有正整数整除的整数，所以不存在最大元</p><h2 id="上界-upper-bound-和下界-lower-bound"><a href="#上界-upper-bound-和下界-lower-bound" class="headerlink" title="上界(upper bound)和下界(lower bound)"></a>上界(upper bound)和下界(lower bound)</h2><p>​        有时候可以找到<strong>一个元素大于或等于偏序集（S，&lt;&#x3D;）的子集A中的所有元素**。如果u是S中的元素，对所有的元素$a\in A$有**a&lt;&#x3D;u**，那么称u为A的一个上界，类似的 ，对所有的元素$a\in A$有**a&gt;&#x3D;u</strong>，那么称u为A的一个下界（<font color="red">别忘了考虑元素本身</font>）</p><p>**最小上界(least upper bound)**：x是一个上界并且它小于A的任何其他的上界</p><p><strong>最大下界(greatest lower bound)</strong>:x是一个下界并且它大于A的任何其他的上界</p><p>eg：</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-04_09-48-18.png"></p><p>{a,b,c}的上界是e,f,h,j,下界是a</p><p>{j,h}没有上界，下界是a,b,c,d,e,f</p><p>{a,c,d,f}的上界是f,h,j下界是a</p><p>{b,d,g}的最大下界是b，最小上界是g</p><h2 id="格-lattice"><a href="#格-lattice" class="headerlink" title="格(lattice)"></a>格(lattice)</h2><p>​        如果偏序集的每对元素都有最小上界和最大下界，就称这个偏序集为格</p><p> eg：</p><p>  1.偏序集($Z^+$,|)是格吗</p><p>​       设a和b是两个正整数，这两个正整数的最小上界和最大下界是他们的最小公倍数和最大公约数，因此是格</p><ol start="2"><li>（{1,2,3,4,5}，|）是否为格</li></ol><p>​       2,3两个元素在偏序集中没有上界，故不是格</p><h2 id="拓扑排序-topological-sorting"><a href="#拓扑排序-topological-sorting" class="headerlink" title="拓扑排序(topological sorting)"></a>拓扑排序(topological sorting)</h2><p>引理：每个有穷非空偏序集(S,&lt;&#x3D;)至少有一个极小元</p><p>根据这个引理我们根据以下几个步骤进行拓扑排序：</p><ul><li>找到S中的极小元</li><li>将S替换为S-{a}</li><li>重复上述操作，直到S&#x3D;{}</li></ul><p> <img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-04_10-19-16.png"></p><h1 id="数学结构（mathmatical-structure）"><a href="#数学结构（mathmatical-structure）" class="headerlink" title="数学结构（mathmatical structure）"></a>数学结构（mathmatical structure）</h1><p>定义在对象集合上的一些运算和伴随的属性构成了数学结构</p><p>eg:</p><p>​     [sets,$\cup$,$\cap$,-],前者是对象，后面是运算</p><p>​     [3$\times$3matrices,+,*,T]</p><h2 id="二元运算"><a href="#二元运算" class="headerlink" title="二元运算"></a>二元运算</h2><h3 id="封闭性-closure"><a href="#封闭性-closure" class="headerlink" title="封闭性(closure)"></a>封闭性(closure)</h3><p>​        假如一个运算总是能产生对象集合里的另一个成员，那么说这个结构关于该运算是封闭的</p><p>eg：</p><ul><li>[5$\times$5matrices,+,*,T]关于加法操作是封闭的，因为两个5$\times$5矩阵相加是另一个5$\times$5矩阵</li><li>[odd integers,+,*]关于加法操作是不封闭的，因为两个奇数相加是偶数</li></ul><p>二元运算（binary operation）:需要两个元素</p><p>一元运算（unary operation）:只需要一个元素</p><h3 id="交换性（commutative）"><a href="#交换性（commutative）" class="headerlink" title="交换性（commutative）"></a>交换性（commutative）</h3><p>​        如果元素的顺序不会影响二元运算最后的结果，我们称这个运算是交换性的</p><p>​      ·是一个二元运算，如果x·y&#x3D;y·x，这个二元运算时交换性的</p><p>eg：</p><ul><li>$A\cup B$&#x3D;$B\cup A$是可交换的</li><li>矩阵相乘是不可交换的</li></ul><h3 id="结合性（associative）"><a href="#结合性（associative）" class="headerlink" title="结合性（associative）"></a>结合性（associative）</h3><p>​     ·是一个二元运算，如果（x·y）·z&#x3D;x·（y·z），这个二元运算是交换性的</p><p>eg：</p><ul><li>$(A\cup B)\cup C&#x3D;A\cup(B\cup C)$</li></ul><h3 id="分配性（distributive-property）"><a href="#分配性（distributive-property）" class="headerlink" title="分配性（distributive property）"></a>分配性（distributive property）</h3><p>如果一个数学结构有两个二元运算·和$\nabla$，分配性有如下特点：</p><p>​        $x·(y\nabla z)&#x3D;(x·y)\nabla (x·z)$</p><p>eg:</p><ul><li>a*(b+c)&#x3D;a<em>c+b</em>c</li></ul><h3 id="德·摩根律-de-morgan’s-laws"><a href="#德·摩根律-de-morgan’s-laws" class="headerlink" title="德·摩根律(de morgan’s laws)"></a>德·摩根律(de morgan’s laws)</h3><p>如果一元操作*和两个二元操作·和$\nabla$,那么德摩根律是：</p><p>​    $(x·y)^*&#x3D;x^<em>\nabla y^</em>以及(x\nabla y)^*&#x3D;x^<em>·y^</em>$</p><p>eg:</p><ul><li>$\overline{A\cup B}&#x3D;\overline{A}\cap \overline{B}$</li></ul><h2 id="半群与群-semigroups-and-group"><a href="#半群与群-semigroups-and-group" class="headerlink" title="半群与群(semigroups and group)"></a>半群与群(semigroups and group)</h2><h3 id="半群-semigroup"><a href="#半群-semigroup" class="headerlink" title="半群(semigroup)"></a>半群(semigroup)</h3><p>​       定义：S是一个非空集合，S上有二元运算*，满足结合律，则称{S,*}或S为一个半群。</p><ul><li>半群满足结合性</li><li>半群一定是封闭的</li></ul><h3 id="单位元-identity-幺半群-monoid"><a href="#单位元-identity-幺半群-monoid" class="headerlink" title="单位元(identity),幺半群(monoid)"></a>单位元(identity),幺半群(monoid)</h3><p>若 S 是一个半群，且对任意 $a \in M$ 都有 $ea&#x3D;ae&#x3D;a$ 则称 $e$ 为 S 的<strong>幺元或单位元</strong></p><p><strong>幺半群</strong>就是含有单位元的半群</p><p>对应幺半群来说，单位元是唯一的，记为 $e$</p><h3 id="子半群-subsemigroup"><a href="#子半群-subsemigroup" class="headerlink" title="子半群(subsemigroup)"></a>子半群(subsemigroup)</h3><ul><li>$(S,*)$是半群，并且$T$是$S$的子集</li><li>如果$(T,<em>)$也是封闭的那么说$(T,</em>)$是$S,*$的子半群</li></ul><h3 id="子独异点-submonoid"><a href="#子独异点-submonoid" class="headerlink" title="子独异点(submonoid)"></a>子独异点(submonoid)</h3><ul><li>$(S,*)$是幺半群，有单位元$e$,$T$是$S$的非空子集</li><li>如果$(T,<em>)$是封闭的那么说$(T,</em>)$是$S,*$的子独异点</li></ul><p>Note：</p><ul><li>半群的任何子集都有结合性的特点，所以子半群也是半群</li><li>相同的，子独异点也是幺半群</li></ul><h3 id="a的幂-powers"><a href="#a的幂-powers" class="headerlink" title="a的幂(powers)"></a>a的幂(powers)</h3><p>如果：</p><ul><li>$(S,*)$是半群，$a \in S,n \in Z^+$</li></ul><p>定义：</p><ul><li>$a^1&#x3D;a,a^n&#x3D;a^{n-1}*a,n&gt;&#x3D;2$</li><li>$a^0&#x3D;e$，如果$(S,*)是幺半群$</li></ul><h3 id="同构映射-isomorphism"><a href="#同构映射-isomorphism" class="headerlink" title="同构映射(isomorphism)"></a>同构映射(isomorphism)</h3><ul><li>$(S,<em>)$和$(T,</em>‘)$是两个半群</li><li>存在映射$f:S-&gt;T$</li></ul><p>满足条件：</p><ul><li>这是一个从$S$到$T$的双射</li><li>对于所有S中的a,b来说，有$f(a<em>b)&#x3D;f(a)</em>‘f(b)$</li></ul><p>满足这个映射的两个半群被称作<strong>isomorphic</strong>，写作$S$ <pre>&#x224C;<pre>T</pre></pre></p><p>tips：</p><ul><li>如果f是从$(S,<em>)$到$(T,</em>')$的同构映射，那么$f^{-1}$是从$(T,<em>)$到$(S,</em>)$的同构映射</li></ul><p>证明isomorphic</p><ol><li>定义一个映射f，$f:S->T$同时Dom(f)=S</li><li>证明f是满射</li><li>证明f是单射</li><li>证明$f(a<em>b)=f(a)</em>'f(b)$</li></ol><p>eg：</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-14_23-01-27.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-14_23-01-42.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-14_23-01-52.png"></p><p>结论1：</p><ul><li>$(S,<em>)$和$(T,</em>')$是幺半群，并分别有单位元$e$和$e'$</li><li>$f:S->T$是同构映射</li><li>有$f(e)=e'$</li></ul><p>结论2：</p><ul><li>$(S,<em>)$和$(T,</em>')$都是半群</li><li>S有单位元而T没有单位元</li><li>那么$(S,<em>)$和$(T,</em>)$不是同构映射</li></ul><h3 id="同态-homomorphism"><a href="#同态-homomorphism" class="headerlink" title="同态(homomorphism)"></a>同态(homomorphism)</h3><ul><li>$(S,<em>)$和$(T,</em>')$是两个半群</li><li>存在映射$f:S->T$</li></ul><p>满足条件：</p><ul><li>对于所有S中的a,b来说，有$f(a<em>b)=f(a)</em>'f(b)$</li></ul><p>如果f是满射的话，称$T$是$S$的同态像(homomorphic image)</p><p>同构是一种特殊的同态，即存在一个双射的同态</p><p>结论1：</p><ul><li>$f$是从半群$(S,<em>)$到$T,</em>'$的一个同态</li><li>$S'$是$(S,*)$的子半群</li><li>有$f(S')={t \in T|t=f(s)for some s\in S'}$,$S'$在$f$下的值域是$(T,*')$的子半群</li></ul><p>结论2：</p><ul><li>$f$是从<font color="red">可交换(commutative)</font>的半群$(S,<em>)$到半群$(T,</em>')$的<font color="red">满射(onto)</font></li><li>那么$(T,*')$也是可交换的</li></ul><h2 id="乘积半群，商半群-products-and-quotients-of-semigroups"><a href="#乘积半群，商半群-products-and-quotients-of-semigroups" class="headerlink" title="乘积半群，商半群(products and quotients of semigroups)"></a>乘积半群，商半群(products and quotients of semigroups)</h2><p>如果$(S,<em>)$和$(T,</em>')$是半群，如果对于运算$<em>''$有$(s_1,t_1)</em>''(s_2,t_2)=(s_1<em>s_2,t_1</em>'t_2)$</p><p>那么可以说$(S \times T,*'')$是一个半群</p><p>如果S和T都是独异点，那么其乘积半群也是独异点且单位元是$（e_s，e_t）$</p><h3 id="同余关系-congruence-relation"><a href="#同余关系-congruence-relation" class="headerlink" title="同余关系(congruence relation)"></a>同余关系(congruence relation)</h3><p>定义在半群$(S,*)$的<strong>等价关系(equivalence relation)R</strong>满足以下条件：</p><ul><li>如果a R a'和b R b'</li><li>有$(a*b)R(a'*b')$</li></ul><p>称为同余关系(congruence relation)</p><h3 id="商半群-quotient-semigroup"><a href="#商半群-quotient-semigroup" class="headerlink" title="商半群(quotient semigroup)"></a>商半群(quotient semigroup)</h3><ul><li>R是定义在半群$(S,*)$上的同余关系</li><li>通过这个同余关系我们可以构建商集合<strong>S/R</strong></li><li><strong>S/R</strong>的元素是S集合中的等价类</li><li>定义另一个运算#，有$[a]#[b]=[a*b]$</li><li>那么$(S/R,#)$是半群，<strong>S/R</strong>称为商半群(quotient semigroup)</li><li>如果$(S,*)$是幺半群，那么$(S/R,#)$也是幺半群</li></ul><p>eg:</p><blockquote><p>首先，我们定义一个半群，即整数集合Z（包括正整数、负整数和零）和乘法运算。乘法运算是整数乘法。</p><p>然后，我们定义一个等价关系∼，使得对于任意的正整数a和b，a∼b当且仅当它们具有相同的约数集合。</p><p>通过这个等价关系，我们可以构建商集合，记作Z/∼。商集合中的元素是整数集合中的等价类。</p><p>具体来说，我们考虑正整数的等价类。例如，等价类[1]包含所有只有1作为约数的正整数，即{1, 2, 3, 5, 7, ...}。等价类[2]包含所有只有2作为约数的正整数，即{2, 4, 6, 8, 10, ...}。等价类[3]包含所有只有3作为约数的正整数，即{3, 6, 9, 12, 15, ...}，以此类推。</p><p>现在，我们定义商乘法⊕，使得对于商集合Z/∼中的等价类[a]和[b]，它们的乘法运算[a]⊕[b]等于a和b的乘积的等价类。换句话说，[a]⊕[b]=[a*b]。</p><p>因此，在这个例子中，商半群的元素是整数集合中的正整数的等价类。每个等价类包含具有相同约数集合的正整数。商半群的乘法运算是通过正整数乘法来定义的，结果是两个正整数乘积的等价类。</p></blockquote><p>结论：</p><ul><li>R是定义在$(S,*)$上的同余关系</li><li>$(S/R,#)$是相应的商半群</li><li>由$f(a)=[a]$定义的$f:S->S/R$是满射(onto)的同态，称为<strong>自然同态(natural homomorphism)</strong></li></ul><h3 id="同态基本定理-fundamental-homomorphism-theorem"><a href="#同态基本定理-fundamental-homomorphism-theorem" class="headerlink" title="同态基本定理(fundamental homomorphism theorem)"></a>同态基本定理(fundamental homomorphism theorem)</h3><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-15_12-19-54.png"></p><h2 id="群-group"><a href="#群-group" class="headerlink" title="群(group)"></a>群(group)</h2><p>群是一个集合加上一个运算*，写作(G,*),它有以下性质</p><ul><li>封闭性(closure)，对于所有<em>G</em>中<em>a</em>,<em>b</em>，运算<em>a</em>·<em>b</em>的结果也在<em>G</em>中。</li><li>结合性（Associativity）：对于所有<em>G</em>中的<em>a</em>,<em>b</em>和<em>c</em>，等式 (<em>a</em>·<em>b</em>)·<em>c</em>=<em>a</em>· (<em>b</em>·<em>c</em>)成立。</li><li>单位元（Identity element）：<em>G</em>中存在一个元素<em>e</em>，对于所有<em>G</em>中的元素<em>a</em>，等式$e<em>a = a</em>e = a $</li><li>逆元（Inverse element）：对于每个<em>G</em>中的<em>a</em>，存在<em>G</em>中的一个元素$a`或a^{-1}$使$a*a^{-1}=a^{-1}*a=e$</li></ul><h3 id="阿贝尔群-abelian"><a href="#阿贝尔群-abelian" class="headerlink" title="阿贝尔群(abelian)"></a>阿贝尔群(abelian)</h3><p>一个群被称为阿贝尔群，如果满足以下性质</p><ul><li>对于所有G中的a,b来说，有<strong>ab=ba</strong></li></ul><p>证明:</p><ul><li>封闭性</li><li>结合性</li><li>存在单位元</li><li>存在逆元</li><li>满足ab=ba</li></ul><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-19_15-55-31.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-19_15-56-07.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-19_15-56-20.png"></p><p>结论：</p><ul><li>G是一个群，对于G中的每个元素a来说，a在G中只有一个逆元</li><li>G是一个群，a，b，c是G中的元素<ul><li>ab=ac可推出b=c(左消去律)</li><li>ba=ca可推出b=c(右消去律)</li></ul></li><li>G是一个群，a，b是G中的元素<ul><li>$(a^{-1})^{-1}=a$</li><li>$(ab)^{-1}=b^{-1}a^{-1}$</li></ul></li><li>G是一个群，a，b是G中的元素<ul><li>方程ax=b在G中有唯一解</li><li>方程ya=b在G中有唯一解</li></ul></li></ul><h3 id="有限群-finite-group"><a href="#有限群-finite-group" class="headerlink" title="有限群(finite group)"></a>有限群(finite group)</h3><p>设G是一个群， 如果G是有限集合，那么就称为<strong>有限群</strong>。</p><p>假若群G是一个有限群，则组成G的元的个数为G的**阶(order)**，记为 |G|。</p><p>有了有限群，可以画出乘法表(multiplication table)</p><p>表中每行每列不能有重复元素</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-19_17-05-59.png"></p><h3 id="n次对称群-symmetric-group-on-n-lettters"><a href="#n次对称群-symmetric-group-on-n-lettters" class="headerlink" title="n次对称群(symmetric group on n lettters)"></a>n次对称群(symmetric group on n lettters)</h3><p>n的所有置换组成的集合是一个阶为n!的群</p><p>这个群称作n次对称群，而且被标记为$S_n$</p><p>由部分置换构成的群称为置换群(permutation group)</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-19_22-48-12.png"></p><h3 id="子群-subgroup"><a href="#子群-subgroup" class="headerlink" title="子群(subgroup)"></a>子群(subgroup)</h3><p>H是群S的子群，满足以下条件</p><ul><li>H包含S的单位元</li><li>结合律</li><li>封闭性</li><li>$a\in H$那么$a_{-1}\in H$</li></ul><p>G是一个群，那么G本身和H={e}是G的子群，称为平凡子群(trivial subgroups)</p><p>eg:</p><p>$S_3$的所有子群</p><p>{<em>f</em>1},{<em>f</em>1, <em>g</em>1},{<em>f</em>1, <em>g</em>2},{<em>f</em>1, <em>g</em>3},{<em>f</em>1, <em>f</em>2, <em>f</em>3},<em>S</em>3</p><p>结论：</p><ul><li><p>$(G,<em>)$和$(G',</em>')$是两个群</p></li><li><p>映射$f:G->G'$是从G到G‘的同态，有(homomorphism)</p><ul><li>e是G的单位元，e’是G‘的单位元，有f(e)=e'</li><li>如果$a\in G$有$f(a^{-1})=(f(a))^{-1}$</li><li>H是G的子群，then <em>f</em>(<em>H</em>) = {<em>f</em>(<em>h</em>)|<em>h</em> Î <em>H</em>} 是 <strong>G</strong>'的子群</li></ul></li><li><p>当两个群之间存在一个同构映射时，这意味着它们具有相同的代数结构。</p><ul><li>例如S3是不是阿贝尔群而Z6是阿贝尔群，那么他们就不是同构映射</li></ul></li></ul><p>table9.5被称作克莱因四元素群(klein 4 group)，被记作<strong>V</strong></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-20_00-20-29.png"></p><h3 id="循环群-cyclic-group"><a href="#循环群-cyclic-group" class="headerlink" title="循环群(cyclic group)"></a>循环群(cyclic group)</h3><p>循环群是一种特殊的群，它由一个元素生成并且群的运算是乘法。具体来说，对于一个循环群 G，存在一个元素 g，当对其进行重复乘法运算时，可以得到 G 中的所有元素。这样的元素 g 被称为循环群 G 的生成元。</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-20_00-01-25.png"></p><h2 id="群的积与商"><a href="#群的积与商" class="headerlink" title="群的积与商"></a>群的积与商</h2><p>G1,G2是两个群，那么G=G1×G2也是一个群</p><p>G中的元素为(a1,b1)(a2,b2)=(a1a2,b1b2)</p><p>其中a1,a2属于G1，b1,b2属于G2</p><p><img src="/Clear1oveE/Clear1oveE.github.io/"></p><p>Note:</p><ul><li>当m，n的最大公因数是1时</li><li>有$Z_m\times Z_n与Z_{mn}同构$</li></ul><p>结论</p><ul><li>当时群(G,*)上的同余关系</li><li>当半群(G/R,#)满足$[a]#[b]=[a*b]$时，它是一个群</li></ul><h3 id="左陪集-left-coset-，右陪集-right-coset-正规子群-normal"><a href="#左陪集-left-coset-，右陪集-right-coset-正规子群-normal" class="headerlink" title="左陪集(left coset)，右陪集(right coset),正规子群(normal)"></a>左陪集(left coset)，右陪集(right coset),正规子群(normal)</h3><ul><li>H是群G的子群</li><li>$a\in G$</li></ul><p>H在G上的由a定义的左陪集，是集合</p><p>$aH={ah|h\in H}$</p><p>H在G上的由a定义的右陪集，是集合</p><p>$Ha={ha|h\in H}$</p><ul><li>当对于所有G中的a来说，有aH=Ha</li><li>那么说子集H是G的正规子群</li></ul><p>Note：</p><ul><li>如果$a\in H$那么$aH=H$</li></ul><h1 id="群与编码-groups-and-coding"><a href="#群与编码-groups-and-coding" class="headerlink" title="群与编码(groups and coding)"></a>群与编码(groups and coding)</h1><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-26_19-08-57.png"></p><p>存在<strong>n>m</strong>且是单射的映射$e:B^m->B^n$</p><ul><li>e被称作(m,n)的<strong>编码函数(encoding function)</strong></li><li>如果$b\in B^m$那么e(b)被称作代表b的<strong>码字(code word)</strong></li></ul><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-26_19-12-37.png"></p><p>当传输时如果x和$x_t$有至少1个至多k个位置有不同时，我们称x=e(b)在传输时有小于等于k个errors</p><ul><li>对于$x\in B^n$，x中1的数量被称作x的<strong>权(weight)<strong>，记为</strong>|x|</strong></li></ul><h2 id="奇偶校验码-parity-check-code"><a href="#奇偶校验码-parity-check-code" class="headerlink" title="奇偶校验码(parity check code)"></a>奇偶校验码(parity check code)</h2><p>当编码函数$e:B^m->B^{m+1}$满足</p><ul><li>如果$b=b_1b_2...b_m\in B^m$那么$e(b)=b_1b_2...b_mb{m+1}$</li></ul><p>我们称其为<strong>parity(m,m+1) check node</strong></p><p>其中$b_{m+1}$</p><ul><li>=0(当|b|是偶数)</li><li>=1(当|b|是奇数)</li></ul><h2 id="海明距离-hamming-distance"><a href="#海明距离-hamming-distance" class="headerlink" title="海明距离(hamming distance)"></a>海明距离(hamming distance)</h2><p>用来表示两串二进制编码中不同位置的数量</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-26_19-26-49.png"></p><h2 id="最小距离-minimum-distance"><a href="#最小距离-minimum-distance" class="headerlink" title="最小距离(minimum distance)"></a>最小距离(minimum distance)</h2><p>编码函数$e:B^m->B^n$的最小距离，是在所有码字对(code words)中的最小距离</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-26_19-30-37.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-26_19-32-19.png"></p><h2 id="群码-group-codes"><a href="#群码-group-codes" class="headerlink" title="群码(group codes)"></a>群码(group codes)</h2><p>(m,n)编码函数$e:B^m->B^n$满足</p><ul><li>$e(B^m)={e(b)|e(b)\in B^n}$</li><li>是$B^n$的子群<ul><li>N包含$B^n$的单位元</li><li>x，y属于N，那么x，y逐位相加对二取模构成的序列也属于N</li><li>x属于N，x的逆元也属于N</li></ul></li></ul><p>被称作群码</p><ul><li>对一个群码来说，他的最小距离就是其中非零码字的权</li></ul><h1 id="constructing"><a href="#constructing" class="headerlink" title="constructing"></a>constructing</h1><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-26_20-08-18.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-26_20-08-35.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-26_20-12-08.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-26_20-13-39.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-26_20-13-48.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-26_20-14-27.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-26_20-16-03.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-11-02_13-16-49.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/discrete%20mathematics/Snipaste_2023-10-26_20-16-12.png"></p><p>​                                                        </p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统</title>
      <link href="/Clear1oveE/Clear1oveE.github.io/2023/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>/Clear1oveE/Clear1oveE.github.io/2023/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'],['\\(','\\)']]} }); </script> <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script><h1 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h1><h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><h3 id="布尔运算（Boolean-Algebras）"><a href="#布尔运算（Boolean-Algebras）" class="headerlink" title="布尔运算（Boolean Algebras）"></a>布尔运算（Boolean Algebras）</h3><ul><li><p>&amp;表交集</p></li><li><p>|表并集</p></li><li><p><font color="red">~</font>表非</p></li><li><p><font color="red">^</font>表异或</p></li></ul><h3 id="位向量"><a href="#位向量" class="headerlink" title="位向量"></a>位向量</h3><p><strong>位向量</strong>的一个应用是表示有限集合，我们可以用[a<sub>w-1</sub>,..,a<sub>1</sub>,a<sub>0</sub>]编码A{0，1，…,m-1}的任何子集。&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p><p>比如我们可以用&#x2F;&#x2F;</p><p>位向量a&#x3D;[01101001]表示集合A&#x3D;{0,3,5,6}</p><p>位向量b&#x3D;[071010101]表示集合B&#x3D;{0,2,4,6&#x2F;}</p><p>使用这种编码集合，布尔运算&amp;和|分别表示集合的交和并，而~对应于集合的补，例如a&amp;b&#x3D;[01000001]</p><h3 id="位运算（Bit-Level-Operations）"><a href="#位运算（Bit-Level-Operations）" class="headerlink" title="位运算（Bit-Level Operations）"></a>位运算（Bit-Level Operations）</h3><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-14_20-35-41.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-14_20-38-05.png"></p><h3 id="逻辑运算（Logic-Operations-）"><a href="#逻辑运算（Logic-Operations-）" class="headerlink" title="逻辑运算（Logic Operations ）"></a>逻辑运算（Logic Operations ）</h3><p>Logic Operations: <strong>&amp;&amp;</strong>, <strong>||</strong>, <strong>!</strong></p><ul><li>把0看作false</li><li>非零全都视作true</li></ul><p>example：</p><ul><li>!0x41-&gt;0x00</li><li>!0x00-&gt;0x01</li><li>!!0x41-&gt;0x01</li><li>0x69&amp;&amp;0x55-&gt;0x01</li><li>0x69||0x55-&gt;0x01</li></ul><h3 id="移位操作（Shift-Operations）"><a href="#移位操作（Shift-Operations）" class="headerlink" title="移位操作（Shift Operations）"></a>移位操作（Shift Operations）</h3><p>Left Shift: x&lt;&lt; y</p><ul><li>扔掉x左边y位数</li><li>在右边填上相应数量的0</li></ul><p>Right Shift: x&gt;&gt; y</p><p>右移分为两种</p><ul><li><strong>Logical shift</strong><ul><li>扔掉右边y位数</li><li>在左边填上相应数量的0</li></ul></li><li><strong>Arithmetic shift</strong> <ul><li>扔掉右边y位数</li><li>在左边填上相应数量的最高位数字</li></ul></li></ul><p><font color="red">一般对有符号数使用算数右移，无符号数只能是逻辑右移</font></p><h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><p>描述用位来编码整数的两种不同方式</p><ul><li>只能表示非负数（Unsigned）</li><li>表示负数，零和正数（Two’s Complement（补码））</li></ul><h3 id="数学术语"><a href="#数学术语" class="headerlink" title="数学术语"></a>数学术语</h3><ul><li>B2T<del>w</del>：二进制转补码</li><li>B2U<del>w</del>：二进制转无符号数</li><li>U2B<del>w</del>：无符号数转二进制</li><li>U2T<del>W</del>：无符号转补码</li><li>T2B<del>w</del>:    补码转二进制</li><li>T2U<del>w</del>:    补码转无符号数</li><li>TMin<del>w</del>：补码最小值</li><li>TMax<del>w</del>：补码最大值</li><li>UMax<del>w</del>：最大无符号数</li></ul><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/6059bd34c7c1b76913c2efe757b38cf3cee4037e/Snipaste_2023-09-17_18-47-22.png"></p><h3 id="补码与无符号数的范围"><a href="#补码与无符号数的范围" class="headerlink" title="补码与无符号数的范围"></a>补码与无符号数的范围</h3><p><strong>UMin&#x3D;0   ,UMax&#x3D;2^w^-1(111….1)</strong></p><p><strong>TMin&#x3D;-2^w-1^(1000..0),TMax&#x3D;2^w-1^-1(0111…1),Minus 1(11111)</strong></p><p>Observation:</p><ul><li>|TMin|&#x3D;Tmax+1</li><li>UMax&#x3D;2*Tmax+1</li></ul><h3 id="补码与无符号数之间的转换"><a href="#补码与无符号数之间的转换" class="headerlink" title="补码与无符号数之间的转换"></a>补码与无符号数之间的转换</h3><ul><li>两者之间转换，不改变任何东西，只改变解读数的方法</li><li><font color="red">如果一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数转换为无符号参数</font></li></ul><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/6059bd34c7c1b76913c2efe757b38cf3cee4037e/Snipaste_2023-09-17_18-58-54.png"></p><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>无符号：</p><p>0&lt;&#x3D;x,y&lt;2^w^</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-19_11-23-36.png"></p><p>有符号：</p><p>-2^w-1^&lt;&#x3D;x,y&lt;&#x3D;2^w-1^-1</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-19_11-25-38.png"></p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>无符号：</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-19_11-33-06.png"></p><p>有符号：</p><ul><li>先将补码转换成原码再相乘</li><li>补码转原码步骤是取反再加1(符号位保持不变)</li></ul><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-19_11-35-10.png"></p><h3 id="快速进行2的n次方的乘除运算"><a href="#快速进行2的n次方的乘除运算" class="headerlink" title="快速进行2的n次方的乘除运算"></a>快速进行2的n次方的乘除运算</h3><p>乘：</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-19_11-38-07.png"></p><p>除：</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-19_11-38-58.png"></p><h3 id="求负数"><a href="#求负数" class="headerlink" title="求负数"></a>求负数</h3><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-19_11-43-32.png"></p><h2 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h2><h3 id="小端法和大端法"><a href="#小端法和大端法" class="headerlink" title="小端法和大端法"></a>小端法和大端法</h3><p>小端法：最低有效字节在前面</p><p>大端法：最高有效字节在前面</p><p>eg：在0x01234567中，高位字节的十六进制为0x01，低位字节为0x67</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-19_19-52-34.png"></p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>* byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_bytes</span><span class="params">(byte_pointer start,<span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="comment">//该指针每次只在内存中读取一字节内容，只能以16进制表示</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_int</span><span class="params">(<span class="type">int</span> *start,<span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="comment">//该指针每次在内存中读取并处理四字节内容，使每个start[i]中储存一个整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> test = <span class="number">0x87654321</span>;</span><br><span class="line">byte_pointer i =(byte_pointer) &amp; test;</span><br><span class="line"><span class="type">int</span>* i2 = &amp;test;</span><br><span class="line">show_bytes(i, <span class="number">4</span>);<span class="comment">//输出 21 43 65 87</span></span><br><span class="line">show_int(i2, <span class="number">1</span>);<span class="comment">//输出87654321</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_bytes</span><span class="params">(byte_pointer start, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2x &quot;</span>,start[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_int</span><span class="params">(<span class="type">int</span>* start, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2x &quot;</span>, start[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>* byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_bytes</span><span class="params">(byte_pointer start,<span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* s = <span class="string">&quot;abcdef&quot;</span>;<span class="comment">//const char* s = &quot;abcdef&quot;; 的意义是将字符串字面值 &quot;abcdef&quot; 的内存首地址赋值给指针 s。</span></span><br><span class="line">show_bytes((byte_pointer)s,<span class="built_in">strlen</span>(s));<span class="comment">//结果是61 62 63 64 65 66 “a~z”的ASCII码是0x61~0x7A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_bytes</span><span class="params">(byte_pointer start, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2x &quot;</span>,start[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>tips:</p><ul><li>在补码中$T_{min}$和0的负数都是他本身，是特殊情况，记得要考虑</li></ul><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-21_19-38-01.png"></p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>二进制小数点向左移动一位相当于这个数被2除，向右移动一位相当于将该数乘二</p><p>例如0.11…11的数表示刚好小于1的数，例如0.11111，我们将用简单的表达法$1.0-\epsilon$来表示这么样的数值</p><h3 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h3><p><strong>IEEE浮点标准用$V&#x3D;(-1)^s\times M\times 2^E$的形式来表示一个数</strong></p><ul><li>符号(sign)   <code>s</code>决定这数是负数(s&#x3D;1)还是整数(s&#x3D;0)</li><li>尾数(significand) <code>M</code>是一个<strong>二进制小数</strong>，它的范围是$1到2-\epsilon$(规格化)，或者是$0到1-\epsilon$(非规格化)</li><li>阶码(exponent) <code>E</code>的作用是对浮点数加权</li></ul><p>将浮点数的位表示划分为三个字段，分别对这些值进行编码</p><ul><li>一个单独的符号位<code>s</code></li><li><code>k</code>位的阶码字段exp&#x3D;$e_{k-1}..e_1e_0$编码阶码<code>E</code></li><li><code>n</code>位小数字段frac&#x3D;$f_{n-1}..f_1f_0$编码尾数<code>M</code></li></ul><p>单精度浮点格式，k&#x3D;8，n&#x3D;23</p><p>双精度浮点格式，k&#x3D;11，n&#x3D;52</p><p>根据exp的值，被编码的值可以分为三种不同情况</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-10-30_23-01-40.png"></p><ul><li>规格化的(exp的位模式不全为0，也不去全为1)<ul><li>阶码的值是$E&#x3D;e-Bias$,e是无符号数，Bias等于$2^{k-1}-1$(单精度是127，双精度是1023),由此产生的指数值单精度是-126到+127，双精度是-1022到+1023</li><li>尾数定义为$M&#x3D;1+f$</li></ul></li><li>非规格化的值(阶码域为全0)<ul><li>$E&#x3D;1-bias$</li><li>$M&#x3D;f$</li></ul></li><li>无穷大(阶码全为1，小数域全为0) <ul><li>得到的值表示无穷</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-10-30_23-02-16.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-10-30_23-02-39.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-10-30_23-03-12.png"></p><h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>有四种舍入方式</p><ul><li>向偶数舍入：四舍五入，当遇到中间值时，使得结果的最低有效数字是偶数 eg:1.5和2.5d都舍入成2</li><li>向零舍入：正数向下舍入，负数向上舍入</li><li>向下舍入：把负数和正数都向下舍入</li><li>向上舍入：把正数和负数都向上舍入</li></ul><h1 id="数据的机器级表示"><a href="#数据的机器级表示" class="headerlink" title="数据的机器级表示"></a>数据的机器级表示</h1><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-21_19-50-30.png"></p><p>数据传送指令有四个变种：</p><ul><li>movb (传送1字节)</li><li>movw（传送两字节）</li><li>movl (传送四字节)</li><li>movq (传送八字节)</li><li>后缀”l”用来表示四字节整数和八字节双精度浮点数</li></ul><h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p>​        一个x86-64的中央处理器单元(CPU)包含一组16个存储64位值的通用目的寄存器。</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-21_19-53-27.png"></p><h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>大多数指令有一个或多个操作数，各种不同的操作数被分为三中类型：</p><ul><li><strong>立即数（immediate）</strong>:书写方式是‘$’后面跟一个用标准C表示法表示的整数,如<strong>$-577</strong>或<strong>$0x1F</strong></li><li><strong>寄存器(register)</strong>:16个寄存器的低位1字节，2字节，4字节，8字节中的一个作为操作数，这些字节数分别对应8位，16位，32位，64位。我们用$r_a$来表示任意寄存器a，引用R[$r_a$]来表示它的值</li><li><strong>内存引用(memory)</strong>:他会根据计算出来的地址访问某个内存地址。用M[Addr]表示对存储在内存中从地址Addr开始的b个字节的引用</li></ul><p>如下图所示，有多种不同的寻址模式，$Imm(r_b,r_i,s)$最常见的形式，这样的引用有四个组成部分</p><ul><li>立即数偏移$Imm$</li><li>基址寄存器$r_b$</li><li>变址寄存器$r_i$</li><li>比例因子s</li></ul><p>有效地址被计算为<br>$$<br>Imm+R[r_b]+R[r_i]*s<br>$$<br>tips:</p><ul><li><font color="red">基址和变址寄存器必须是64位寄存器</font></li><li>s必须是1,2,4,8.</li></ul><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-21_20-28-28.png"></p><p>eg:</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-24_23-01-08.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-21_20-29-02.png"></p><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>​        最频繁使用的指令是将数据从一个位置复制到另一个位置的指令,最简单形式的数据传送指令——MOV类，这些指令把数据从源位置复制到目的位置。</p><p>​        MOV类由四条指令组成:movb,movw,movl,movq</p><p>源操作数指定的值(有三种)是一个立即数,存储在寄存器中或内存中.</p><p>目的操作数指定一个位置(只有两种，不包含立即数)要么是一个寄存器，要么是一个内存地址</p><p>tips:</p><ul><li>目的操作数不能是立即数</li><li>两个操作数不能都指向内存位置</li><li>寄存器部分的大小必须与指令最后一个字符(b,w,l,q)指定的大小匹配</li><li>不能将形如32位寄存器的值移到64位寄存器中</li></ul><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-21_20-40-23.png"></p><p>​        在将较小的源值复制到较大的目的时应使用下述两类数据移动指令</p><ul><li><p>先看寄存器，再看立即数，最后看内存</p></li><li><p>MOVZ类：把目的中剩余的字节填充为0</p></li><li><p>MOVS类：通过符号扩展来填充，把源操作的最高位进行复制</p></li><li><p>每条指令名字的最后两个字符都是大小指示符：第一个字符指定源的大小，第二个指明目的大小</p></li></ul><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-21_20-53-57.png"></p><h4 id="数据传输示例"><a href="#数据传输示例" class="headerlink" title="数据传输示例"></a>数据传输示例</h4><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-26_17-02-35.png"></p><p>​         exchange由三条指令实现：两个数据传送（movq），加上一条返回函数被调用点的指令<font color="red">（ret）</font>，参数通过寄存器传递给函数，<font color="red">函数通过把值存储在寄存器%rax或该寄存器的某个低位部分中返回</font></p><ul><li>像x这样的局部变量通常保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多</li></ul><h4 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h4><ul><li>通过push操作把数据压入栈中，通过pop操作删除数据</li><li>栈总是从一端插入和删除元素。这一端被称为栈顶，栈指针%rsp指向栈顶元素</li><li>栈向下增长，栈顶元素是所有栈中元素最低的（依照惯例，栈是倒过来画的，栈顶在图的底部）</li><li>栈指针%rsp保存栈顶元素的地址</li></ul><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-26_18-16-25.png"></p><p>​        pushq和popq这两个指令都只有一个操作数—压入的数据源和弹出的数据目的</p><p>​        将一个四字值压入栈中，首先要将栈指针减8，然后将值写到新的栈顶地址，pushq %rbq的行为等价于下面两条指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq $8,%rsp</span><br><span class="line">movq %rbq,(%rsp)</span><br></pre></td></tr></table></figure><p>​       弹出一个四字操作包括包括从栈顶位置读出数据，然后将栈指针加8,popq %rax等价于下面两条指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq (%rsp),%rax</span><br><span class="line">addq $8,%rsp</span><br></pre></td></tr></table></figure><h3 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h3><p>​        指令类ADD由四条加法指令组成：addb,addw,addl,addq，分别是字节加法，字加法，双字加法和四字加法</p><p>​        整数和逻辑操作被分为四组：</p><ul><li><p>加载有效地址</p></li><li><p>一元操作</p></li><li><p>二元操作</p></li><li><p>移位</p><p>二元操作有两个操作数，一元操作有一个操作数</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-26_19-22-03.png"></p></li></ul><h4 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h4><p>leap实际上是movq指令的变形，可以简洁的描述普通的算数操作。例如，如果寄存器%rdx的值为x，那么</p><p>leap 7(%rdx,%rdx,4),%rax</p><p>将设置寄存器%rax的值为5x+7</p><p><font color="red">目的操作数必须是一个寄存器</font></p><h4 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h4><p>​        一元操作：只有一个操作数，既是源又是目的。这个操作数<font color="red">可以使一个寄存器，也可以是一个内存位置</font></p><p>​        二元操作：第一个操作数可以使立即数，寄存器或内存位置，第二个操作数可以使寄存器或是内存位置</p><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subq %rax,%rdx//使寄存器%rdx的值减去%rax中的值</span><br></pre></td></tr></table></figure><h4 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h4><p>先给出位移量，第二项给出的是要移位的数。</p><ul><li>移位量可以是一个立即数，或者放在单字节寄存器%cl中，<font color="red">移位操作的目的数可以是一个寄存器或是一个内存位置</font></li><li>移位量是由%cl寄存器的低m位决定的，例如当寄存器%cl的十六进制值为0xFF时，指令salb会移7位，salw会移15位，sall会移31位，而salq会移63位</li><li>左移指令有两个名字：<strong>SAL</strong>和<strong>SHL</strong>，两者效果一样，都是将右边填上0</li><li>右移指令不同，SAR执行算数移位（填上符号位），SHR执行逻辑移位（填上0）</li></ul><h4 id="特殊的算数操作"><a href="#特殊的算数操作" class="headerlink" title="特殊的算数操作"></a>特殊的算数操作</h4><p>​        图中描述的是支持产生两个64位数字的全128位乘积以及整数除法的指令</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-09-26_19-36-32.png"></p><p>imulq有两种不同形式</p><ul><li>双操作数乘法指令，从两个64位操作数产生一个64位乘积</li><li>单操作数乘法指令，计算两个64位值的全128位乘积，一个是无符号数乘法（mulq）而另一个是补码乘法（imulq）。<ul><li>这两条指令都要求一个参数必须在寄存器**%rax<strong>中，而另一个作为指令的源操作数给出，然后乘积存放在寄存器</strong>%rdx（高64位）<strong>和</strong>%rax（低64位）**中</li></ul></li></ul><p>idivl（有符号除法指令）</p><ul><li>将寄存器**%rdx（高64位）<strong>和</strong>%rax（低64位）**中的128位数作为被除数，而出书作为指令的操作数给出</li><li>指令将商存储在寄存器**%rax<strong>中，将余数存储在寄存器</strong>%rdx**中</li><li>除数也常常是一个64位的值，这个值应存放在%rax中，%rdx应该设置为0（无符号运算）或者%rax的符号位（有符号运算）</li></ul><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><h4 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h4><p>最常用的条件码：</p><ul><li>CF：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出</li><li>ZF：零标志。最近的操作得出的结果为0</li><li>SF：符号标志。最近的操作得到的结果为负数</li><li>OF：溢出标志。最近的操作导致一个补码的溢出——正溢出或负溢出</li></ul><h5 id="CMP指令和SUB指令"><a href="#CMP指令和SUB指令" class="headerlink" title="CMP指令和SUB指令"></a>CMP指令和SUB指令</h5><p>这两类指令他们<strong>只设置条件码</strong>而不改变任何其他寄存器</p><p>CMP指令根据两个操作数之差来设置条件码，如果两个操作数相等，这些指令会将零标志设置为1，其他标志可以用来确认两个操作数之间的大小关系(注意顺序)</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-10-09_22-15-47.png"></p><h5 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h5><p>条件码通常不会直接读取，常用的使用方法有三种：</p><ol><li>根据条件码的某种组合，将一个字节设置为0或1</li><li>可以条件跳转到程序的某个其他部分</li><li>可以有条件的传送数据</li></ol><blockquote><p>SET指令</p></blockquote><p>我们将这一整类指令称为SET指令，他们之间的区别在于他们考虑的条件码组合是什么</p><p>一条SET指令的目的操作数是<strong>低位单字节寄存器元素</strong>，或是一个字节的内存位置，指令会将这个字节设置成0或者1</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-10-09_22-42-48.png"></p><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    mov %r0, 10    ; 将值 10 存储在 %r0 寄存器中</span><br><span class="line">    cmp %r0, 5     ; 比较 %r0 的值和 5</span><br><span class="line">    setg %al       ; 如果 %r0 &gt; 5，则将标志位中的 &quot;大于&quot; 标志位设置到 %al 中</span><br></pre></td></tr></table></figure><blockquote><p>跳转指令</p></blockquote><p>正常执行的情况下，指令按照他们出现的顺序一条一条的执行。跳转（jump）指令会导致执行切换到程序中一个全新的位置</p><p>跳转分为直接跳转和间接跳转</p><ul><li>直接跳转：跳转目标是作为指令的一部分编码的</li><li>间接跳转：跳转目标是从寄存器或内存位置中读出的,写法是<code>*</code>后面跟一个操作数指示符<ul><li>jmp *%rax 用寄存器%rax中的值作为跳转目标</li><li>jmp *(%rax)以%rax的值作为读地址，从内存中读出跳转目标</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-10-09_22-55-14.png"></p><blockquote><p>跳转指令的编码</p></blockquote><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-10-09_22-59-20.png"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-10-12_20-37-06.png"></p><p>如何看跳转的地址：</p><ul><li>先看jmp语句的下一个语句的地址(第二行跳转指令的下一行地址是0X4004d5)</li><li>看跳转指令那行的目标编码(通常在第二个字节中，题目可能会不同)，这里是0X03</li><li>将目标编码转换为10进制数(如第二个跳转指令的目标编码为0Xf8，转换为十进制是-8)<ul><li>先将十六进制转换为二进制，首位为0则正常转换为10进制，首位为1，则将其他七位取反再加1，再转换为10进制，最后加个负号</li></ul></li><li>跳转指令的下一行地址，一定是跳转指令这一行的地址加2</li></ul><blockquote><p>用条件控制来实现条件分支</p></blockquote><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-10-09_23-19-56.png"></p><p>条件传输指令有两个操作数：</p><ul><li>源寄存器或者内存地址S</li><li>目的寄存器R</li></ul><p>当指定条件被满足时，源值(S)会被复制到目的寄存器(R)中</p><p><img src="https://raw.githubusercontent.com/Clear1oveE/copy.github.io/master/Computer%20System/Snipaste_2023-10-12_20-47-51.png"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/Clear1oveE/Clear1oveE.github.io/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/Clear1oveE/Clear1oveE.github.io/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><p><strong>数据元素，数据项:</strong></p><ul><li><strong>数据元素</strong>是数据的<font color="red">基本单位</font>,通常作为一个整体进行考虑和处理</li><li>一个<strong>数据元素</strong>由若干<strong>数据项</strong>组成，<strong>数据项</strong>是构成<strong>数据元素</strong>的<font color="red">不可分割的最小单位</font>，如果一个数据项由多个更细分的属性组成，我们称为<strong>组合项</strong></li><li>eg:一个人的姓名，学号，年龄，生日分别是一个<strong>数据项</strong>共同构成一个<strong>数据元素</strong>，其中生日包含年，月，日等更细分的属性，所以生日是组合项</li></ul><p><font color="red">注意区分数据对象和数据结构</font></p><p><strong>数据对象：</strong>是<font color="red">具有相同性质</font>的<strong>数据元素</strong>的集合，是<strong>数据</strong>的一个子集</p><p><strong>数据结构</strong>：是<font color="red">相互之间存在一种或多种特定关系</font>的<strong>数据元素</strong>的集合，<strong>数据元素</strong>相互之间的关系称为<strong>结构（structure）</strong></p><p><strong>四类基本结构</strong>：</p><ul><li>集合:各个元素同属一个集合，并为其他关系</li><li>线性结构：数据元素是一对一关系</li><li>树形结构：数据元素之间是一对多的关系</li><li>图状结构或网格结构：数据元素之间是多对多的关系</li></ul><p><strong>基本运算</strong></p><ul><li>查找第i个数据元素</li><li>在第i个位置插入新的数据元素</li><li>删除第i个位置的数据元素</li></ul><p><strong>物理结构（存储结构）</strong></p><ul><li>顺序存储：把逻辑上相邻的元素存储在物理位置也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现</li><li>链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素的逻辑关系</li><li>索引存储：存储元素信息时，还建立附加的索引表。索引表每项称为索引项，其一般形式为（关键字，地址）</li><li>散列存储：根据元素的关键字直接计算出元素的地址，又称哈希存储</li></ul><p>在计算机中表示信息的最小单位是二进制数的一位，叫做<strong>位（bit）</strong></p><p>在计算机中我们可以用一个由若干<strong>位</strong>组合起来形成的一个位串表示一个数据元素，称这个位串为<strong>元素（element）</strong>或<strong>节点（node）</strong></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>​       栈是一种特殊的线性表，具有<strong>后进后出</strong>的特点，限定为只能在表尾进行插入和删除操作</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习中</title>
      <link href="/Clear1oveE/Clear1oveE.github.io/2023/09/11/C-%E5%AD%A6%E4%B9%A0%E4%B8%AD/"/>
      <url>/Clear1oveE/Clear1oveE.github.io/2023/09/11/C-%E5%AD%A6%E4%B9%A0%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h1><h2 id="C-的两个模板"><a href="#C-的两个模板" class="headerlink" title="C#的两个模板"></a>C#的两个模板</h2><p>​      Main（）是C#应用程序的主入口点，执行程序时，无论是<strong>控制台应用程序</strong>还是<strong>Windows窗体应用程序</strong>都从Main（）主程序开始。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//加入程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        通常来说按下F5键，控制台窗口会立即关闭。为了让程序执行的结果画面暂停，在主程序Main（）末尾加上如下语句：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     Console.WriteLine(<span class="string">&quot;我的第一个C#程序&quot;</span>);</span><br><span class="line">     Console.ReadLine();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Windows-窗体应用程序"><a href="#Windows-窗体应用程序" class="headerlink" title="Windows 窗体应用程序"></a>Windows 窗体应用程序</h3><p>​     添加第二个项目。依次选择菜单选项**”文件-&gt;添加-&gt;新建项目”**，添加Windows窗体应用模板；</p><p>​     在窗体上加入控件。在<strong>工具箱</strong>中展开<strong>公共控件</strong>；将<strong>Label</strong>和<strong>Button</strong>控件添加到窗体中</p><p>​     选择控件，将“属性”窗口的<strong>Font</strong>展开，可以改变字体；<strong>Text</strong>可以改变控件的命名</p><p>​     鼠标双击<strong>Button</strong>控件，进入其事件处理程序并编写程序代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            label1.Text = <span class="string">&quot;Visual C#应用程序&quot;</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="设计语言结构"><a href="#设计语言结构" class="headerlink" title="设计语言结构"></a>设计语言结构</h2><h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><p>读取有三种方法：</p><ul><li>Console.Read();&#x2F;&#x2F;从标准数据流读取<strong>下一个字符</strong></li><li>Console.ReadLine();&#x2F;&#x2F;读取用户输入的<strong>一连串字符</strong>，可以通过变量储存该字符串</li><li>Console.ReadKey()&#x2F;&#x2F;获取用户按下的<strong>下一个字符或功能键</strong></li></ul><h4 id="用ReadLine读取数据"><a href="#用ReadLine读取数据" class="headerlink" title="用ReadLine读取数据"></a>用ReadLine读取数据</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           Console.Write(<span class="string">&quot;请输入你的名字：&quot;</span>);</span><br><span class="line">           <span class="built_in">string</span> name = Console.ReadLine();</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;Good day!&#123;0&#125;&quot;</span>, name);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>​        值得一提的是，在 C# 中，您可以使用字符数组来表示字符串，但是，更常见的做法是使用 <strong>string</strong> 关键字来声明一个字符串变量。string 关键字是 <strong>System.String</strong> 类的别名。</p><p>下面是string与字符数组的一些区别：</p><ul><li>string可以包含任意数量的字符，但一旦存入，字符串是不可变的，这意味着一旦创建，就不能对其进行更改。如果需要更改字符串，需要创建一个新的字符串对象。</li><li>与字符串不同，字符数组是可变的，并且可以直接更改。</li></ul><p>下面是一个例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> myString = <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 创建一个字符串对象</span></span><br><span class="line"><span class="built_in">char</span> myChar = <span class="string">&#x27;H&#x27;</span>; <span class="comment">// 创建一个字符变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问字符串中的单个字符</span></span><br><span class="line"><span class="built_in">char</span> firstChar = myString[<span class="number">0</span>]; <span class="comment">// 获取字符串的第一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作字符串</span></span><br><span class="line"><span class="built_in">string</span> newString = myString.Replace(<span class="string">&quot;World&quot;</span>, <span class="string">&quot;C#&quot;</span>); <span class="comment">// 替换字符串中的部分内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储多个字符</span></span><br><span class="line"><span class="built_in">char</span>[] letters = &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span> &#125;; <span class="comment">// 创建一个字符数组</span></span><br><span class="line"><span class="built_in">char</span> firstLetter = letters[<span class="number">0</span>]; <span class="comment">// 获取字符数组的第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改字符</span></span><br><span class="line">letters[<span class="number">0</span>] = <span class="string">&#x27;e&#x27;</span>; <span class="comment">// 更改字符数组的第一个元素</span></span><br></pre></td></tr></table></figure><h2 id="折叠代码"><a href="#折叠代码" class="headerlink" title="折叠代码"></a>折叠代码</h2><p>#region+tab键即可创建折叠变量</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> 任意命名</span></span><br><span class="line">    <span class="comment">//代码区域</span></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> 1.有符号的整型变量</span></span><br><span class="line"><span class="comment">//sbyte -128~127</span></span><br><span class="line"><span class="built_in">sbyte</span> sb = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印方法</span></span><br><span class="line">Console.WriteLine(sb);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印中文的话，通过+来拼接打印</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;sbyte中储存的值是：&quot;</span> + sb);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法,注意加上$</span></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;sbyte中储存的值是：<span class="subst">&#123;sb&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//int -21亿~21亿</span></span><br><span class="line"><span class="built_in">int</span> p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//short -32768~32767</span></span><br><span class="line"><span class="built_in">short</span> s = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//long -9百万兆~9百万兆</span></span><br><span class="line"><span class="built_in">long</span> l = <span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> 2.无符号的整型变量</span></span><br><span class="line"><span class="comment">//byte 0~255</span></span><br><span class="line"><span class="built_in">byte</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//uint 0~42亿</span></span><br><span class="line"><span class="built_in">uint</span> ui = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//ushort 0~65535</span></span><br><span class="line"><span class="built_in">ushort</span> us = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//ulong 0~18百万兆</span></span><br><span class="line"><span class="built_in">ulong</span> ul = <span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> 3.浮点数（小数）</span></span><br><span class="line"><span class="comment">//float 存储7位有效数字，注意后面加上f</span></span><br><span class="line"><span class="comment">//之所以要加f，是因为c#中申明的小数，默认是double类型的，加f是告诉系统是float类型的</span></span><br><span class="line"><span class="built_in">float</span> f = <span class="number">1.0123456789f</span>;</span><br><span class="line">Console.WriteLine(f);</span><br><span class="line"><span class="comment">//double 存储15~17有效数字</span></span><br><span class="line"><span class="built_in">double</span> d = <span class="number">0.123456789123456789</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> 4.特殊类型</span></span><br><span class="line"><span class="comment">//bool true fasle 表示真假的数据类型</span></span><br><span class="line"><span class="built_in">bool</span> bo = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">bool</span> bo2 = <span class="literal">false</span>;</span><br><span class="line">Console.WriteLine(bo + <span class="string">&quot;_&quot;</span> + bo2);</span><br><span class="line"><span class="comment">//char 用来存储单个字符的变量类型,加‘’</span></span><br><span class="line"><span class="built_in">char</span> c = <span class="string">&#x27;龙&#x27;</span>;</span><br><span class="line">Console.WriteLine(c);</span><br><span class="line"><span class="comment">//string 是字符串类型，用来存储多个字符，没有上限</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;sahdahsldnhlkd&quot;</span>;</span><br><span class="line">Console.WriteLine(str);</span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串与整数的转换"><a href="#字符串与整数的转换" class="headerlink" title="字符串与整数的转换"></a>字符串与整数的转换</h2><p>当使用<strong>Console.Readline（）</strong>得到用户输入的整数时，得到的是一个字符串而不是整数，此时是不可以进行加减乘除的基本运算的，此时学要用<strong>Convert</strong>将字符串转换成整数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//基础写法</span></span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();<span class="comment">//此时str储存的是字符串</span></span><br><span class="line">    <span class="built_in">int</span> strInt=Convert.ToInt32(str);<span class="comment">//将字符串转化成整数</span></span><br><span class="line">    Console.WriteLine(strInt+<span class="number">17</span>);<span class="comment">//不转化的话输出的是1317，转化后输出30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//简便写法</span></span><br><span class="line">    <span class="built_in">int</span> strInt2 = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">    Console.WriteLine(strInt2+<span class="number">17</span>);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="built_in">int</span> randomNumber = random.Next(<span class="number">0</span>, <span class="number">101</span>); <span class="comment">// 生成一个 0 到 100 之间的整数</span></span><br><span class="line">        Console.WriteLine(randomNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明</span></span><br><span class="line">    <span class="built_in">int</span>[] age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个固定大小的数组</span></span><br><span class="line">    <span class="built_in">int</span>[] ages=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    <span class="built_in">int</span>[] ages1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一种方法赋值</span></span><br><span class="line">    <span class="built_in">int</span>[] ages2;</span><br><span class="line">    ages2=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;Clearlove&quot;</span>;</span><br><span class="line">        <span class="comment">//倒序输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = str.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将字符串全部变为小写</span></span><br><span class="line">        <span class="built_in">string</span> str1=str.ToLower();</span><br><span class="line">        Console.WriteLine(str1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将字符串全部大写</span></span><br><span class="line">        <span class="built_in">string</span> str2=str.ToUpper();</span><br><span class="line">        Console.WriteLine(str2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//去除字符串前后空格</span></span><br><span class="line">        <span class="built_in">string</span> _str = <span class="string">&quot;  Clearlove  &quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> _str1=_str.Trim();</span><br><span class="line">        Console.WriteLine(_str+<span class="string">&quot;||&quot;</span>+_str1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分割</span></span><br><span class="line">        <span class="built_in">string</span> str_ = <span class="string">&quot;Clearlove,smlz,Lwx&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span>[] strArray=str_.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="built_in">string</span> temp <span class="keyword">in</span> strArray)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参数数组"><a href="#参数数组" class="headerlink" title="参数数组"></a>参数数组</h2><p>在函数形参需要传递一个数组时，如果不加上<strong>params</strong>，那么在传递数组时，需要自己构造一个有长度的数组，但使用参数数组后，只需要传数组里的数，系统会帮你自动构建数组</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="built_in">int</span> temp <span class="keyword">in</span> array)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//系统帮我们自动构造数组</span></span><br><span class="line">           <span class="built_in">int</span> num=Add(<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>);</span><br><span class="line">           Console.WriteLine(num);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//自己构造数组的两种方法</span></span><br><span class="line">           <span class="built_in">int</span> num2=Add2(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;);</span><br><span class="line"></span><br><span class="line">           <span class="built_in">int</span>[] array = &#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">           <span class="built_in">int</span> num3=Add2(array);</span><br><span class="line">           Console.ReadLine();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> GameState</span><br><span class="line">&#123;</span><br><span class="line">    Menu,Pause,False,Success</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GameState state = GameState.Menu;</span><br><span class="line"><span class="built_in">int</span> num = (<span class="built_in">int</span>)state;</span><br><span class="line">Console.WriteLine(state);</span><br><span class="line">Console.WriteLine(num);</span><br></pre></td></tr></table></figure><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _029_委托</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Multiply</span>(<span class="params"><span class="built_in">double</span> param1,<span class="built_in">double</span> param2</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> param1 * param2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Divide</span>(<span class="params"><span class="built_in">double</span> param1,<span class="built_in">double</span> param2</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> param1 / param2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">delegate</span> <span class="built_in">double</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">double</span> param1,<span class="built_in">double</span> param2</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyDelegate delegate1 = Multiply;</span><br><span class="line">            MyDelegate delegate2 = Divide;</span><br><span class="line">            Console.WriteLine(delegate1(<span class="number">2</span>,<span class="number">4</span>) + delegate2(<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _030_委托的使用</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">OnDie</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Play</span>(<span class="params">OnDie onDie</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;战斗&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;死亡&quot;</span>);</span><br><span class="line">            onDie();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DieUI</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;返回首页&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Play(DieUI);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结构体函数"><a href="#结构体函数" class="headerlink" title="结构体函数"></a>结构体函数</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _027_结构体函数</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> Position</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">double</span> x;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">double</span> y;   </span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">double</span> z;</span><br><span class="line">            <span class="comment">//可以在结构体里面定义函数，并且不需要传参，参数就是结构体的变量</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>()</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;x:&#123;0&#125;,y:&#123;1&#125;,z:&#123;2&#125;&quot;</span>, x, y, z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">struct</span> Name</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> firstName;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> lastName;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">fullName</span>()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span>+ lastName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Position pos;</span><br><span class="line">            pos.x = <span class="number">12.25</span>;</span><br><span class="line">            pos.y = <span class="number">5.88</span>;</span><br><span class="line">            pos.z = <span class="number">7.77</span>;</span><br><span class="line">            pos.Print();</span><br><span class="line"></span><br><span class="line">            Name name;</span><br><span class="line">            name.firstName = <span class="string">&quot;Steven&quot;</span>;</span><br><span class="line">            name.lastName = <span class="string">&quot;Jobs&quot;</span>;</span><br><span class="line">            Console.WriteLine(name.fullName());</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="try-catch-finally语句进行异常处理"><a href="#try-catch-finally语句进行异常处理" class="headerlink" title="try-catch-finally语句进行异常处理"></a>try-catch-finally语句进行异常处理</h2><p><strong>try</strong>块包含可能出现异常的代码（一条或多条），当try块程序检测到异常后会放弃执行后续代码，直接跳到catch块，执行catch块代码</p><p><strong>catch</strong>块用来捕捉异常，当代码块发生异常并与catch块中参数类型一样时就会执行，如果不写参数（不加括号），表示发生任何异常都会执行这个catch块</p><p><strong>finally</strong>包含始终都会执行的代码，不管有没有异常产生都会执行</p><p><strong>catch</strong>可能有<strong>0个或多个</strong>，<strong>finally</strong>可能有<strong>0个或一个</strong>，catch块和finally块至少要存在一个</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _002_<span class="title">try_catch_finally</span>语句进行异常处理</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;请输入两个整数&quot;</span>);</span><br><span class="line">            <span class="built_in">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在用户没有输入正确的情况下，一直输入</span></span><br><span class="line">          <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    num1 = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">                    num2 = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">                    Console.WriteLine(num1 + num2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (FormatException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;出现异常：&#123;0&#125;&quot;</span> + <span class="string">&quot;请重新输入&quot;</span>, e.Message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类里面使用private进行访问权限控制"><a href="#类里面使用private进行访问权限控制" class="headerlink" title="类里面使用private进行访问权限控制"></a>类里面使用private进行访问权限控制</h2><p>​        类里面的数据通常设置为<strong>private</strong>，这样数据只能在当前类里面使用，而无法被外界修改和访问。我们可以通过在类里面设置public的Set和Get方法来使得外界操作数据。不用Set和Get的话，外界能直接给数据赋值，无法做到赋值的限制，而使用私有属性通过Set和Get方法进行读取和输出能在方法中添加一些规则对输入和输出进行限制</p><p>​       类里面包含<strong>属性</strong>，属性包含set和get函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"> <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速设置（可以在get和set前设置只读或只写）</span></span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">get</span>;<span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//传统设置，可以添加条件</span></span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">get</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> age;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">set</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>（age&lt;<span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span></span><br><span class="line">         age = <span class="keyword">value</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以在不设置变量的情况下直接使用（系统会自动生成string address）</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Address</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span>;<span class="keyword">set</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>用于初始化</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boss</span>(<span class="params"><span class="built_in">int</span> attack,<span class="built_in">int</span> HP,<span class="built_in">int</span> speed,<span class="built_in">int</span> baseHP</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.attack = attack;</span><br><span class="line">    <span class="keyword">this</span>.HP = HP;</span><br><span class="line">    <span class="keyword">base</span>.HP = HP;</span><br><span class="line">    <span class="keyword">this</span>.speed = speed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子类的构造函数"><a href="#子类的构造函数" class="headerlink" title="子类的构造函数"></a>子类的构造函数</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hp;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseClass</span>(<span class="params"><span class="built_in">int</span> hp, <span class="built_in">int</span> speed</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.hp = hp;</span><br><span class="line">        <span class="keyword">this</span>.speed = speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">DrivedClass</span>:<span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> attack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrivedClass</span>(<span class="params"><span class="built_in">int</span> attack,<span class="built_in">int</span> hp,<span class="built_in">int</span> speed</span>):<span class="title">base</span>(<span class="params">hp,speed</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.attack = attack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>​        当所有子类的攻击方法各不相同，如果父类里有攻击的方法，那么所有子类都要重写一遍，这样十分麻烦，这时可以使用抽象类，只声明方法，但不写方法内的函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Enemy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Attack</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;敌人移动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Boss</span> : <span class="title">Enemy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Attack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boss攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boss移动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口的书写"><a href="#接口的书写" class="headerlink" title="接口的书写"></a>接口的书写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">interface</span> <span class="title">IFly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//注意不允许使用修饰符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FlyAttack</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">BIrd</span> : <span class="title">IFly</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;小鸟在空中飞&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FlyAttack</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;小鸟在空中攻击&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Plane</span> : <span class="title">IFly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;飞机在空中飞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FlyAttack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;飞机在空中攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="接口在主函数里的应用"><a href="#接口在主函数里的应用" class="headerlink" title="接口在主函数里的应用"></a>接口在主函数里的应用</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Plane p= <span class="keyword">new</span> Plane();</span><br><span class="line">        p.Fly();</span><br><span class="line">        p.FlyAttack();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//多态</span></span><br><span class="line">        IFly fly = <span class="keyword">new</span> BIrd();</span><br><span class="line">        fly.Fly();</span><br><span class="line">        fly.FlyAttack();</span><br><span class="line"></span><br><span class="line">        fly=<span class="keyword">new</span> Plane();</span><br><span class="line">        fly.FlyAttack();</span><br><span class="line"></span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h2><h3 id="设置索引器"><a href="#设置索引器" class="headerlink" title="设置索引器"></a>设置索引器</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Class1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>[] name = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name[index]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            name[index] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种索引器中使用函数设置</span></span><br><span class="line"> <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="built_in">string</span>[] week=<span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">7</span>] &#123;<span class="string">&quot;Mon&quot;</span>,<span class="string">&quot;Tus&quot;</span>,<span class="string">&quot;Wed&quot;</span>,<span class="string">&quot;Tus&quot;</span>,<span class="string">&quot;Frd&quot;</span>,<span class="string">&quot;Sat&quot;</span>,<span class="string">&quot;Sun&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetDay</span>(<span class="params"><span class="built_in">string</span> target</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> week)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span> (item != target)</span><br><span class="line">                 count++;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count+<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">string</span> day]</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">get</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">return</span> GetDay(day);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">set</span></span><br><span class="line">         &#123;</span><br><span class="line">             </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="使用索引器"><a href="#使用索引器" class="headerlink" title="使用索引器"></a>使用索引器</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    Test t= <span class="keyword">new</span> Test();</span><br><span class="line">    Console.WriteLine(t[<span class="string">&quot;Frd&quot;</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    Class1 class1 = <span class="keyword">new</span> Class1();</span><br><span class="line">    class1[<span class="number">0</span>] = <span class="string">&quot;xcl&quot;</span>;</span><br><span class="line">    Console.WriteLine(class1[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>在一个类里面重新定义符号的定义，当用这个类创建的对象进行运算时，会使用这个新的运算符定义进行运算</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span>==(Student s1,Student s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.age==s2.age&amp;&amp;s1.id==s2.id&amp;&amp;s1.name==s2.name) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> !=(Student s1, Student s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> jud = s1 == s2;</span><br><span class="line">        <span class="keyword">return</span> !jud;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     Student student1 = <span class="keyword">new</span> Student(<span class="number">7</span>,<span class="string">&quot;xcl&quot;</span>,<span class="number">19</span>);</span><br><span class="line">     Student student2 = <span class="keyword">new</span> Student(<span class="number">7</span>, <span class="string">&quot;xcl&quot;</span>, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">     Console.WriteLine(student1==student2);<span class="comment">//true</span></span><br><span class="line">     Console.WriteLine(student1!=student2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">     Console.ReadKey();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">list.Add(<span class="number">9</span>);</span><br><span class="line">list.Add(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">list.Insert(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">list.Remove(<span class="number">5</span>);</span><br><span class="line">list.RemoveAt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(list.IndexOf(<span class="number">50</span>));</span><br><span class="line">Console.WriteLine(list.LastIndexOf(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Class1</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T a;</span><br><span class="line">    <span class="keyword">public</span> T b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Class1</span>(<span class="params">T a,T b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.a= a;</span><br><span class="line">        <span class="keyword">this</span>.b= b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetSum</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dynamic</span> num1 = a;</span><br><span class="line">        <span class="built_in">dynamic</span> num2 = b;</span><br><span class="line">        <span class="built_in">dynamic</span> result = num1 + num2;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> T <span class="title">GetSum</span>&lt;<span class="title">T</span>&gt;(<span class="params">T a,T b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dynamic</span> A = a;</span><br><span class="line">    <span class="built_in">dynamic</span> B = b;</span><br><span class="line">    <span class="built_in">dynamic</span> sum = A + B;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(GetSum&lt;<span class="built_in">int</span>&gt;(<span class="number">45</span>, <span class="number">72</span>));</span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h2><p>在类内部对ToString方法进行重写，这样在直接调用对象时可以输出定义好的返回值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">     <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> age, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">this</span>.age = age;</span><br><span class="line">         <span class="keyword">this</span>.name = name;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">string</span> result = name + <span class="string">&quot;:&quot;</span> + age;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student(<span class="number">19</span>,<span class="string">&quot;xcl&quot;</span>);</span><br><span class="line">    Console.WriteLine(student);<span class="comment">//返回xcl：19</span></span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Equal"><a href="#Equal" class="headerlink" title="Equal"></a>Equal</h2><p>每个类型都有Equal方法比较，特别情况下可以重写Equal来进行比较</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Student student = obj <span class="keyword">as</span> Student;</span><br><span class="line">    <span class="keyword">if</span>(student.age==age&amp;&amp;student.name==name)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> b=<span class="number">1</span>;</span><br><span class="line">Console.WriteLine(a.Equals(b));</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;xcl&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> name2 = <span class="string">&quot;xcl&quot;</span>;</span><br><span class="line">Console.WriteLine(name.Equals(name2));</span><br><span class="line"></span><br><span class="line">Student stu = <span class="keyword">new</span> Student(<span class="number">18</span>,<span class="string">&quot;xl&quot;</span>);</span><br><span class="line">Student stu1 = <span class="keyword">new</span> Student(<span class="number">18</span>,<span class="string">&quot;xl&quot;</span>);</span><br><span class="line">Console.WriteLine(stu1.Equals(stu));</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>创建多线程之前，你需要创建一个类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _01_多线程</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建多线程，引用已经创建好的一个类</span></span><br><span class="line">            Thread ChildThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(ChildThreadMethod));</span><br><span class="line">            ChildThread.Start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//while(true)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    Console.WriteLine(&quot;聊天中...&quot;);</span></span><br><span class="line">            <span class="comment">//    Thread.Sleep(1000);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="comment">//休眠</span></span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//控制子线程停止</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChildThreadMethod</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;听歌中...&quot;</span>);</span><br><span class="line">                Thread.Sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="绘制直线-x2F-字符串"><a href="#绘制直线-x2F-字符串" class="headerlink" title="绘制直线&#x2F;字符串"></a>绘制直线&#x2F;字符串</h2><p>窗体-&gt;属性-&gt;事件-&gt;Paint-&gt;双击-&gt;在出现的函数里面书写</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Paint</span>(<span class="params"><span class="built_in">object</span> sender, PaintEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建画布</span></span><br><span class="line">    Graphics g = <span class="keyword">this</span>.CreateGraphics();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制直线</span></span><br><span class="line">    Pen p = <span class="keyword">new</span> Pen(Color.Black);</span><br><span class="line">    g.DrawLine(p, <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> Point(<span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制字符串</span></span><br><span class="line">    Font font = <span class="keyword">new</span> Font(<span class="string">&quot;Arial&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    g.DrawString(<span class="string">&quot;xcl&quot;</span>,font,</span><br><span class="line">        <span class="keyword">new</span> SolidBrush(Color.Green),</span><br><span class="line">        <span class="keyword">new</span> Point(<span class="number">100</span>,<span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity</title>
      <link href="/Clear1oveE/Clear1oveE.github.io/2023/07/16/unity/"/>
      <url>/Clear1oveE/Clear1oveE.github.io/2023/07/16/unity/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity使用笔记"><a href="#Unity使用笔记" class="headerlink" title="Unity使用笔记"></a>Unity使用笔记</h1><h2 id="Unity-3D的API"><a href="#Unity-3D的API" class="headerlink" title="Unity 3D的API"></a>Unity 3D的API</h2><ul><li><p><strong>Awake</strong></p><ul><li>条件：实例化脚本时调用</li><li>用途：用于游戏对象的初始化（注意：<strong>Awake</strong>函数的执行早于所有脚本的<strong>Start</strong>函数）</li></ul></li><li><p><strong>OnEnable</strong></p><ul><li>条件：在<strong>Awake</strong>后会调用一次</li><li>用途：组件激活后调用（组件默认都是激活状态，即脚本前打了√的）</li></ul></li><li><p><strong>Start</strong></p><ul><li>条件：在<strong>Update</strong>函数第一次运行前调用</li><li>用途：用于游戏对象的初始化</li></ul></li><li><p><strong>Update</strong></p><ul><li>条件：每<strong>帧</strong>调用一次</li><li>用途：用于更新游戏场景和状态。（注意：与物理状态有关的更新放在<strong>FixedUpdate</strong>函数中）</li></ul></li><li><p><strong>FixedUpdate</strong></p><ul><li>条件：每个<strong>固定物理时间间隔（默认0.02秒）</strong>调用一次</li><li>用于物理状态的更新</li></ul></li><li><p><strong>LateUpdate</strong></p><ul><li>条件：每<strong>帧</strong>调用一次（在<strong>UpDate</strong>函数后）</li><li>用途：用于更新游戏场景和状态（注意：与相机有关更新放在这里）</li></ul></li><li><p><strong>OnDisable</strong></p><ul><li>条件：与<strong>OnEnable</strong>相反，组件未激活时调用一次</li><li>用途：与死亡有关的</li></ul></li><li><p><strong>OnDestroy</strong></p><ul><li>条件：被销毁后调用一次（即移除脚本，注意移除脚本时<strong>OnDisable</strong>也会调用一次且在<strong>OnDestroy</strong>前）</li><li>用途：写伤害或子弹</li></ul></li></ul><h2 id="脚本的执行顺序"><a href="#脚本的执行顺序" class="headerlink" title="脚本的执行顺序"></a>脚本的执行顺序</h2><ul><li>先执行所有脚本的<strong>Awake</strong>再执行所有脚本的<strong>Start</strong></li><li>手动更改脚本执行顺序<ul><li>点开脚本中的<strong>Execution Order</strong></li><li>将脚本添加上去，通过更改数值调换脚本的优先级</li></ul></li><li>把最底层的东西先执行</li></ul><h2 id="脚本的标签"><a href="#脚本的标签" class="headerlink" title="脚本的标签"></a>脚本的标签</h2><ul><li>标签（tag）是用来给开发者标识的，图层是用来给游戏内物体标识的</li><li>标签只是个名字，起到一个分组的作用，让开发者更清楚物体是什么</li><li>图层即给物体一个属性，使我们在unity中可以更方便的对拥有共同属性的物体进行操作（例如：相机的拍摄，物体的碰撞等）</li></ul><h2 id="预设体与变体"><a href="#预设体与变体" class="headerlink" title="预设体与变体"></a>预设体与变体</h2><ul><li>在图层中制作好物体后，将其拖入项目中将变成<strong>预设体</strong></li><li>修改<strong>预设体</strong>的数值或者添加组件，图层中的物体也会改变，反之则不然</li><li>在图层中增加组件或改变数值，可以通过<strong>覆盖</strong>应用到预设体</li><li>当想要预设体中的部分个体有新增的属性而其他属性一样，可以复制一个物体将其拖入项目中设置为<strong>变体</strong></li><li>修改预设体数值，变体也会跟着改变，反之不然</li></ul><h2 id="Vector3的使用"><a href="#Vector3的使用" class="headerlink" title="Vector3的使用"></a>Vector3的使用</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//向量，坐标，旋转，缩放</span></span><br><span class="line"><span class="comment">//初始化vector3，vector3是一个结构体，在c#中初始化时需要使用new</span></span><br><span class="line">Vector3 v = <span class="keyword">new</span> Vector3(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//当然也可以不用new，直接用one，zero，righ等初始化</span></span><br><span class="line">v = Vector3.right;</span><br><span class="line">Vector3 v2 = Vector3.forward;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算两个向量夹角</span></span><br><span class="line">Debug.Log(Vector3.Angle(v, v2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算两点之间的距离</span></span><br><span class="line">Debug.Log(Vector3.Distance(v,v2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//点乘</span></span><br><span class="line">Debug.Log(Vector3.Dot(v, v2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//叉乘</span></span><br><span class="line">Debug.Log(Vector3.Cross(v,v2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//插值，前两个是两个点a，b，第三个参数是两点之间你想取的比例，0就是a，1就是b</span></span><br><span class="line">Debug.Log(Vector3.Lerp(Vector3.one,Vector3.zero,<span class="number">0.7f</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//向量的模</span></span><br><span class="line">Debug.Log(v.magnitude);</span><br><span class="line"></span><br><span class="line"><span class="comment">//单位化向量</span></span><br><span class="line">Debug.Log(v.normalized);</span><br></pre></td></tr></table></figure><h2 id="旋转（同样使用Vector3）"><a href="#旋转（同样使用Vector3）" class="headerlink" title="旋转（同样使用Vector3）"></a>旋转（同样使用Vector3）</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旋转：欧拉角</span></span><br><span class="line">Vector3 rotate = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//旋转：四元数</span></span><br><span class="line"><span class="comment">//无旋转</span></span><br><span class="line">Quaternion quaternion = Quaternion.identity;</span><br><span class="line"></span><br><span class="line"><span class="comment">//欧拉角转四元数</span></span><br><span class="line">quaternion = Quaternion.Euler(rotate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//四元数转欧拉角</span></span><br><span class="line">rotate = quaternion.eulerAngles;</span><br><span class="line"></span><br><span class="line"><span class="comment">//看向一个物体</span></span><br><span class="line">quaternion = Quaternion.LookRotation(<span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    Debug.LogWarning(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    Debug.LogError(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update is called once per frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//绘制一条线</span></span><br><span class="line">    Debug.DrawLine(Vector3.zero,Vector3.one,Color.blue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制一条射线 起点，射线</span></span><br><span class="line">    Debug.DrawRay(Vector3.zero,Vector3.up,Color.red);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一种表示方法</span></span><br><span class="line">    <span class="comment">//起点，终点</span></span><br><span class="line">    Debug.DrawLine(<span class="keyword">new</span> Vector3(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="keyword">new</span> Vector3(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//起点，相对于起点的方向</span></span><br><span class="line">    Debug.DrawRay(<span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="物体属性"><a href="#物体属性" class="headerlink" title="物体属性"></a>物体属性</h2><p>前导：</p><ul><li><code>GameObject</code> 是 Unity 中的一个类，它表示场景中的一个游戏对象。<code>GameObject</code> 类提供了许多方法和属性，用于创建、操作和管理游戏对象。</li><li><code>gameObject</code> 则是 <code>Component</code> 类的一个属性，用于获取该组件所属的游戏对象。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EmptyTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//脚本所挂载的本来就是一个物体a，这步相当于多声明了一个物体b，</span></span><br><span class="line">    <span class="comment">//在unity中我们可以新建一个物体，并把它赋值给b，之后我们可以在a中操作b</span></span><br><span class="line">    <span class="keyword">public</span>  GameObject cc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得预设体</span></span><br><span class="line">    <span class="keyword">public</span> GameObject Prefab;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拿到当前脚本所挂载的物体</span></span><br><span class="line">        GameObject x = <span class="keyword">this</span>.gameObject;</span><br><span class="line">        <span class="comment">//后面没必要这么写了,直接用gameObject表示就行</span></span><br><span class="line">        Debug.Log(x.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//名称</span></span><br><span class="line">        Debug.Log(gameObject.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//tag</span></span><br><span class="line">        Debug.Log(gameObject.tag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//layer</span></span><br><span class="line">        Debug.Log(gameObject.layer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关联物体b的名称</span></span><br><span class="line">        Debug.Log(cc.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关联物体b真正的激活状态(即自身激活，但父物体没激活导致自己没有激活）</span></span><br><span class="line">        Debug.Log(cc.activeInHierarchy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关联物体b自身激活状态</span></span><br><span class="line">        Debug.Log(cc.activeSelf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取Transform组件(x，y，z是三位小数）</span></span><br><span class="line">        Debug.Log(transform.position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其他组件,组件是什么类型，前面的类就是什么</span></span><br><span class="line">        BoxCollider collider = GetComponent&lt;BoxCollider&gt;();</span><br><span class="line">        Debug.Log(collider);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取子物体的某个组件</span></span><br><span class="line">        <span class="comment">//可以先获取指定物体的transform组件，通过这个方法获取指定物体的其他组件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种方法</span></span><br><span class="line">        Transform child=transform.GetChild(<span class="number">0</span>);<span class="comment">//0代表获取第一个子物体</span></span><br><span class="line">        Rigidbody rb = child.GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">        Debug.Log(rb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方法</span></span><br><span class="line">        Transform child2 = transform.Find(<span class="string">&quot;GameObject&quot;</span>);</span><br><span class="line">        Rigidbody rb2 = child2.GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">        Debug.Log(rb2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取子物体的子物体的组件</span></span><br><span class="line">        <span class="comment">//第一种方法</span></span><br><span class="line">        Transform grandchild=transform.GetChild(<span class="number">0</span>).GetChild(<span class="number">0</span>);</span><br><span class="line">        MeshRenderer bc=grandchild.GetComponent&lt;MeshRenderer&gt;();</span><br><span class="line">        Debug.Log(bc.material);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方法(先获取子物体的transform，再获取子物体的子物体的transform）</span></span><br><span class="line">        Transform grandchild2 = child.Find(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">        MeshRenderer bc2 = grandchild2.GetComponent&lt;MeshRenderer&gt;();</span><br><span class="line">        Debug.Log(bc2.material);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取父物体的组件</span></span><br><span class="line">        Transform parent = transform.parent;</span><br><span class="line">        MeshRenderer bc3= parent.GetComponent&lt;MeshRenderer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个组件</span></span><br><span class="line">        gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给关联物体b添加组件</span></span><br><span class="line">        cc.AddComponent&lt;AudioSource&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其他物体</span></span><br><span class="line">        <span class="comment">//通过名称获取</span></span><br><span class="line">        GameObject test = GameObject.Find(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过标签获取(只返回最后创建的一个，多标签没法用）</span></span><br><span class="line">        test = GameObject.FindWithTag(<span class="string">&quot;Enemy&quot;</span>);</span><br><span class="line">        Debug.Log(test.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过预设体来实例化一个游戏物体</span></span><br><span class="line">        Vector3 rotate = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">        GameObject go = Instantiate(Prefab,Vector3.zero,Quaternion.Euler(rotate));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//销毁</span></span><br><span class="line">        Destroy(go);    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TimeTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">float</span> timer = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//游戏开始到现在所花的时间</span></span><br><span class="line">        Debug.Log(UnityEngine.Time.time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//时间缩放值（加速，减速）</span></span><br><span class="line">        Debug.Log(UnityEngine.Time.timeScale);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//固定时间间隔</span></span><br><span class="line">        Debug.Log(UnityEngine.Time.fixedDeltaTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//上一帧到这一帧所用时间</span></span><br><span class="line">        timer += UnityEngine.Time.deltaTime;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (timer &lt;= <span class="number">3</span>)</span><br><span class="line">            Debug.Log(UnityEngine.Time.deltaTime);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Debug.Log(<span class="string">&quot;大于三秒了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件路径权限"><a href="#文件路径权限" class="headerlink" title="文件路径权限"></a>文件路径权限</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">## 场景切换</span></span><br><span class="line"></span><br><span class="line">* 项目--&gt;Scenes文件夹--&gt;新建一个场景--&gt;左上方文件--&gt;生成设置--&gt;将Scenes中的场景拖入build中(记住场景编号，后续有用)</span><br><span class="line"></span><br><span class="line">* 创建一个空对象和脚本</span><br><span class="line">* 导入一个新的名称空间**<span class="keyword">using</span> UnityEngine.SceneManagement**</span><br><span class="line"></span><br><span class="line">```c<span class="meta">#</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进入设置中的1号场景</span></span><br><span class="line">        SceneManager.LoadScene(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//或者通过场景名称的方式</span></span><br><span class="line">        SceneManager.LoadScene(<span class="string">&quot;MyScene&quot;</span>);</span><br><span class="line">        <span class="comment">//后面可以加指令</span></span><br><span class="line">        <span class="comment">//跳转到指定场景</span></span><br><span class="line">        SceneManager.LoadScene(<span class="string">&quot;MyScene&quot;</span>,LoadSceneMode.Single);</span><br><span class="line">        <span class="comment">//让指定场景与当前场景叠加</span></span><br><span class="line">        SceneManager.LoadScene(<span class="string">&quot;MyScene&quot;</span>, LoadSceneMode.Additive);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前场景</span></span><br><span class="line">        Scene scene = SceneManager.GetActiveScene();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//名称</span></span><br><span class="line">        Debug.Log(scene.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//场景是否已经加载</span></span><br><span class="line">        Debug.Log(scene.isLoaded);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//场景路径</span></span><br><span class="line">        Debug.Log(scene.path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//场景索引</span></span><br><span class="line">        Debug.Log(scene.buildIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取场景中的所有物体</span></span><br><span class="line">        GameObject[] gos = scene.GetRootGameObjects();</span><br><span class="line">        Debug.Log(gos.Length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//场景管理类</span></span><br><span class="line">        <span class="comment">//创建一个叫“NewScene”的新场景</span></span><br><span class="line">        Scene newscene = SceneManager.CreateScene(<span class="string">&quot;NewScene&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//已加载场景个数</span></span><br><span class="line">        Debug.Log(SceneManager.sceneCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//卸载场景</span></span><br><span class="line">        SceneManager.UnloadSceneAsync(newscene);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update is called once per frame</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="异步加载场景并显示进度"><a href="#异步加载场景并显示进度" class="headerlink" title="异步加载场景并显示进度"></a>异步加载场景并显示进度</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AsyncTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    AsyncOperation operation;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//新建一个线程，线程内容是loadScene里的内容</span></span><br><span class="line">        StartCoroutine(loadScene());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//远程方法用来异步加载场景</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">loadScene</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        operation=SceneManager.LoadSceneAsync(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//加载完场景不要自动跳转</span></span><br><span class="line">        operation.allowSceneActivation = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">float</span> timer = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//异步加载进度</span></span><br><span class="line">        Debug.Log(operation.progress);</span><br><span class="line">        timer += UnityEngine.Time.deltaTime;</span><br><span class="line">        <span class="keyword">if</span>(timer&gt;<span class="number">5</span>)</span><br><span class="line">            operation.allowSceneActivation=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="transfom入门"><a href="#transfom入门" class="headerlink" title="transfom入门"></a>transfom入门</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TransformTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取位置</span></span><br><span class="line">        <span class="comment">//世界位置</span></span><br><span class="line">        Debug.Log(transform.position);</span><br><span class="line">        <span class="comment">//相对父物体的位置（面板位置）</span></span><br><span class="line">        Debug.Log(transform.localPosition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取旋转</span></span><br><span class="line">        Debug.Log(transform.rotation);</span><br><span class="line">        Debug.Log(transform.localRotation);</span><br><span class="line">        Debug.Log(transform.eulerAngles);</span><br><span class="line">        Debug.Log(transform.localEulerAngles);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取缩放</span></span><br><span class="line">        Debug.Log(transform.localScale);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向量</span></span><br><span class="line">        Debug.Log(transform.forward);<span class="comment">//z</span></span><br><span class="line">        Debug.Log(transform.right);<span class="comment">//x</span></span><br><span class="line">        Debug.Log(transform.up);<span class="comment">//y</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//父子关系</span></span><br><span class="line">        <span class="comment">//子物体个数</span></span><br><span class="line">        Debug.Log(transform.childCount);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//解除与子物体的父子关系</span></span><br><span class="line">        transform.DetachChildren();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断一个物体是不是另一个物体的子物体</span></span><br><span class="line">        Transform child = transform.Find(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">        <span class="built_in">bool</span> jud = child.IsChildOf(transform);</span><br><span class="line">        Debug.Log(jud);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置为父物体</span></span><br><span class="line">        child.SetParent(transform);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//时时刻刻看向某个点</span></span><br><span class="line">        transform.LookAt(Vector3.zero);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自转(绕y轴每帧旋转一度）</span></span><br><span class="line">        transform.Rotate(Vector3.up,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绕某个物体旋转(特定点，轴，旋转角度）</span></span><br><span class="line">        transform.RotateAround(Vector3.zero,Vector3.up,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移动(指定方向是局部方向）</span></span><br><span class="line">        transform.Translate(Vector3.forward*<span class="number">0.1f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="键鼠操作"><a href="#键鼠操作" class="headerlink" title="键鼠操作"></a>键鼠操作</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//鼠标的点击</span></span><br><span class="line">    <span class="comment">//监测瞬间的鼠标操作 0左键 1右键 2滚轮</span></span><br><span class="line">    <span class="comment">//按下鼠标</span></span><br><span class="line">    <span class="keyword">if</span>(Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;按下了左键&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持续按下鼠标按键</span></span><br><span class="line">    <span class="keyword">if</span>(Input.GetMouseButton(<span class="number">0</span>)) &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;持续按下左键&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抬起鼠标</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;抬起了鼠标左键&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按下键盘按键</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.A))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;按下了A键&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持续按下按键</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKey(KeyCode.A))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;持续按下A键&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抬起键盘按键</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyUp(KeyCode.A))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;抬起了A键&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="虚拟轴和虚拟按键"><a href="#虚拟轴和虚拟按键" class="headerlink" title="虚拟轴和虚拟按键"></a>虚拟轴和虚拟按键</h2><ul><li>编辑–&gt;项目设置–&gt;输入管理器–&gt;轴线</li><li>只有水平和垂直是虚拟轴，其他都是虚拟按键</li><li>在里面可以查询名称，后续会使用</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取垂直，水平虚拟轴</span></span><br><span class="line">    <span class="built_in">float</span> horizontal = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);<span class="comment">//“ ”里的是名称，注意不要打错单词</span></span><br><span class="line">    <span class="built_in">float</span> vertical = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">    Debug.Log(horizontal + <span class="string">&quot;    &quot;</span> + vertical);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虚拟按键</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetButtonDown(<span class="string">&quot;Jump&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Jump&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他与上章相同GetButton和GetButtonUp</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>easyx</title>
      <link href="/Clear1oveE/Clear1oveE.github.io/2023/05/17/easyx/"/>
      <url>/Clear1oveE/Clear1oveE.github.io/2023/05/17/easyx/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言使用easyx图形化编程"><a href="#C语言使用easyx图形化编程" class="headerlink" title="C语言使用easyx图形化编程"></a>C语言使用easyx图形化编程</h1><ul><li>首先，使用easyx进行操作必须是<strong>cpp</strong>文件，<strong>切记</strong>。</li><li>头文件–<strong>&lt;graphics.j&gt;</strong></li></ul><h2 id="创建-x2F-关闭一个窗口"><a href="#创建-x2F-关闭一个窗口" class="headerlink" title="创建&#x2F;关闭一个窗口"></a>创建&#x2F;关闭一个窗口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initgraph(<span class="number">640</span>,<span class="number">480</span>，flag);<span class="comment">//创建一个640*480的窗口</span></span><br><span class="line">getchar（）<span class="comment">//在关闭窗口加上，防止闪退</span></span><br><span class="line">closegraph();<span class="comment">//关闭窗口</span></span><br></pre></td></tr></table></figure><p>flag有以下几种功能：</p><ul><li><p>SHOWCONSOLE 显示控制台窗口</p></li><li><p>NOCLOSE 不支持图形化界面关闭</p></li><li><p>NOMINIMIZE 不支持最小化</p></li><li><p>EW_DBLCLKS 支持双击操作</p><h3 id="当想要实现多个功能时如下操作："><a href="#当想要实现多个功能时如下操作：" class="headerlink" title="当想要实现多个功能时如下操作："></a>当想要实现多个功能时如下操作：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initgraph(<span class="number">640</span>, <span class="number">480</span>, EW_DBLCLKS | SHOWCONSOLE | NOCLOSE | NOMINIMIZE);</span><br></pre></td></tr></table></figure></li></ul><h2 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h2><h3 id="图形样式"><a href="#图形样式" class="headerlink" title="图形样式"></a>图形样式</h3><p>填充样式有三类（以画圆为例）：</p><ul><li>circle（）&#x2F;&#x2F;无填充</li><li>fillcircle（）&#x2F;&#x2F;有边框填充</li><li>solidcircle（）&#x2F;&#x2F;无边框填充</li></ul><p>以形状区分，常见的有八种：</p><ul><li><p>circle 画圆  </p></li><li><p>ellipse 画椭圆</p></li><li><p>pie 画扇形</p></li><li><p>polygon 画多边形</p></li><li><p>rectangle 画矩形</p></li><li><p>roundrect 画圆角矩形</p></li><li><p>line 画线</p></li><li><p>putpixle 画点</p></li></ul><h3 id="设置图形颜色"><a href="#设置图形颜色" class="headerlink" title="设置图形颜色"></a>设置图形颜色</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setfillcolor(颜色);<span class="comment">//设置填充颜色</span></span><br><span class="line">setlinecolor(颜色);<span class="comment">//设置线条颜色</span></span><br><span class="line">setlinestyle(线样式，线宽度);<span class="comment">//设置线条样式</span></span><br></pre></td></tr></table></figure><p>线样式有如下几种：</p><ul><li>PS_SOLID &#x2F;&#x2F;实线</li><li>PS_DASH&#x2F;&#x2F;虚线</li><li>PS_DOT&#x2F;&#x2F;······</li><li>PS_DASHDOT&#x2F;&#x2F;—·—·</li><li>PS_DASHDOTDOT&#x2F;&#x2F;—··—··</li></ul><h3 id="设置背景颜色"><a href="#设置背景颜色" class="headerlink" title="设置背景颜色"></a>设置背景颜色</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setckcolor(颜色)<span class="comment">//设置背景板颜色</span></span><br><span class="line">cleardevice();<span class="comment">//清屏</span></span><br><span class="line"><span class="comment">//一定是两步，第一步相当于把背景颜色垫到当前背景颜色下，第二步擦掉最上层颜色，即剩下的就是设置的背景颜色（默认背景板是黑色）</span></span><br></pre></td></tr></table></figure><h2 id="文字绘制函数"><a href="#文字绘制函数" class="headerlink" title="文字绘制函数"></a>文字绘制函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">settextcolor(颜色)；</span><br><span class="line">outtextxy(<span class="number">50</span>,<span class="number">50</span>,<span class="string">&#x27;a&#x27;</span>);<span class="comment">//在（x,y）输出a</span></span><br><span class="line">outtextxy(<span class="number">50</span>, <span class="number">50</span>, <span class="string">&quot;lucky!!!&quot;</span>);<span class="comment">//注意单双引号</span></span><br><span class="line">settextstyle(<span class="number">20</span>,<span class="number">0</span>,<span class="string">&quot;楷体&quot;</span>);<span class="comment">//指定高度，字符的平均宽度，如果是0则比例自适应，字体名称</span></span><br><span class="line">setbkmode(TRANSPARENT);<span class="comment">//设置背景样式,透明</span></span><br><span class="line">settextcolor(RGB(<span class="number">255</span>, <span class="number">102</span>, <span class="number">153</span>));<span class="comment">//获取色号方法：ctrl+alt+k截图，c保存色号，ctrl+v</span></span><br></pre></td></tr></table></figure><h3 id="文字居中"><a href="#文字居中" class="headerlink" title="文字居中"></a>文字居中</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fillrectangle(<span class="number">200</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="type">int</span> width=<span class="number">100</span>/<span class="number">2</span>-textwidth(arr)/<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> hight = <span class="number">100</span> / <span class="number">2</span> - textheight(arr) / <span class="number">2</span>;</span><br><span class="line">outtextxy(width + <span class="number">200</span>, hight + <span class="number">200</span>, arr);</span><br></pre></td></tr></table></figure><p>​        一个简单的算法，用文字框的一半减去字符串的一半即可得到他们之间的距离，用文字框开始的坐标加上这个距离就可使文字居中</p><h2 id="图像处理函数"><a href="#图像处理函数" class="headerlink" title="图像处理函数"></a>图像处理函数</h2><p>​       使用图像前，需要定义一个变量，使用easyx库提供给我们的类型：IMAGE 如：IMAGE img；当然也可以使用数组，存储多张图片</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IMAGE img[<span class="number">1</span>];</span><br><span class="line">loadimage(&amp;img[<span class="number">0</span>],<span class="string">&quot;3.png&quot;</span>,<span class="number">640</span>,<span class="number">480</span>);<span class="comment">//从文件中读取图像</span></span><br><span class="line">putimage(<span class="number">0</span>, <span class="number">0</span>, &amp;img[<span class="number">0</span>]);<span class="comment">//在（x，y）位置绘制指定图像</span></span><br></pre></td></tr></table></figure><h2 id="鼠标处理函数"><a href="#鼠标处理函数" class="headerlink" title="鼠标处理函数"></a>鼠标处理函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Click</span><span class="params">()</span> &#123;</span><br><span class="line">ExMessage msg;<span class="comment">//跟图像处理一样，先定义一个变量，mag是一个结构体，里面储存了多种信息</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (peekmessage(&amp;msg, EX_MOUSE)) &#123;<span class="comment">//检测是否有鼠标点击</span></span><br><span class="line"><span class="keyword">switch</span> (msg.message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:<span class="comment">//左键点击</span></span><br><span class="line"><span class="keyword">if</span> (msg.x &gt;= <span class="number">100</span> &amp;&amp; msg.x &lt;= <span class="number">300</span> &amp;&amp; msg.y &gt;= <span class="number">100</span> &amp;&amp; msg.y &lt;= <span class="number">300</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_RBUTTONDOWN:<span class="comment">//右键点击</span></span><br><span class="line"><span class="keyword">if</span> (msg.x &gt;= <span class="number">100</span> &amp;&amp; msg.x &lt;= <span class="number">300</span> &amp;&amp; msg.y &gt;= <span class="number">100</span> &amp;&amp; msg.y &lt;= <span class="number">300</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yeah&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="窗口处理函数"><a href="#窗口处理函数" class="headerlink" title="窗口处理函数"></a>窗口处理函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Change</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">HWND hnd = GetHWnd();</span><br><span class="line">SetWindowText(hnd, <span class="string">&quot;蕾姆天下第一&quot;</span>);<span class="comment">//修改窗口标题</span></span><br><span class="line"><span class="type">int</span> isok=MessageBox(hnd, <span class="string">&quot;恭喜你，成功中奖500W&quot;</span>, <span class="string">&quot;提示&quot;</span>, MB_OKCANCEL);<span class="comment">//弹出对话框，hnd是强制置顶的功能，换成NULL则取消这个功能</span></span><br><span class="line"><span class="keyword">if</span> (isok == IDOK)<span class="comment">//判断玩家点击对话框</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;天下没有免费的午餐！&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isok == IDCANCEL)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;500W都不要，脑子没事吧？&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>换进制的一些算法</title>
      <link href="/Clear1oveE/Clear1oveE.github.io/2022/11/23/c%E8%AF%AD%E8%A8%80/"/>
      <url>/Clear1oveE/Clear1oveE.github.io/2022/11/23/c%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">convert</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (n%<span class="number">10</span>)+convert(n/<span class="number">10</span>)*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numConvert</span><span class="params">(<span class="type">int</span> number, <span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> N=n,ten=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(number!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        ten=ten+(number%<span class="number">10</span>)*(N/n);</span><br><span class="line">        N=n*N;</span><br><span class="line">        number=number/<span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> three=<span class="number">0</span>,x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ten!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        three=three+(ten%m)*x;</span><br><span class="line">        x*=<span class="number">10</span>;</span><br><span class="line">        ten=ten/m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> three;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十年一舞，终有回响</title>
      <link href="/Clear1oveE/Clear1oveE.github.io/2022/11/20/postDeft/"/>
      <url>/Clear1oveE/Clear1oveE.github.io/2022/11/20/postDeft/</url>
      
        <content type="html"><![CDATA[<h1 id="十年一舞，终有回响"><a href="#十年一舞，终有回响" class="headerlink" title="十年一舞，终有回响"></a>十年一舞，终有回响</h1><h5 id="12班2022211344谢承龙"><a href="#12班2022211344谢承龙" class="headerlink" title="12班2022211344谢承龙"></a>12班2022211344谢承龙</h5><p><img src="https://raw.githubusercontent.com/Clear1oveE/Clear1oveE.github.io/main/2022/11/20/postDeft/1668694528286.jpg" alt="deft"></p><blockquote><p>我个人是从2016年开始接触lol的，当时从客户端页面里第一次看到了lol的职业比赛就被深深吸引住了，后来随着比赛越看越多我也越来越了解每个选手，喜欢上了Clearlove这名选手，也喜欢上了他所在的战队，当时在国内难逢敌手的edg战队，也是从那时第一次认识到了当时edg的顶级“大腿”——deft。后来edg浮浮沉沉，成绩起伏不定，当时edg的选手很多都退役了，deft也离开了edg在这7年时间内辗转数队，因为年龄的增加，状态也不可避免的下滑。今年是他地六次进入s赛，以不被所有人看好的韩国四号种子的身份。他却在自己职业生涯的第十年，打破所有外界的质疑，从入围赛一步步打到决赛，诠释了何为极致的纯粹，以及数十年如一日的对一个目标的不懈追寻所迸发的绚丽火花，在职业生涯的末端为全世界献上了他的名为奇迹的last dance，是我心中很是悸动，久违的感受到了属于电子竞技的魅力，无关国籍，无关立场，单纯地想为这位伟大的选手写一篇博客。 </p></blockquote><p>​    金赫奎（游戏ID：Deft），1996年10月23日出生于韩国<a href="https://baike.baidu.com/item/%E9%A6%96%E5%B0%94/61723?fromModule=lemma_inlink">首尔</a>，韩国<a href="https://baike.baidu.com/item/%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F/4615671?fromModule=lemma_inlink">英雄联盟</a>职业选手，司职<a href="https://baike.baidu.com/item/ADC/3081935?fromModule=lemma_inlink">ADC</a>，曾效力于SSB战队、<a href="https://baike.baidu.com/item/EDG/15092333?fromModule=lemma_inlink">EDG</a>战队、<a href="https://baike.baidu.com/item/KT/18716422?fromModule=lemma_inlink">KT</a>战队、KZ战队、HLE战队，现效力于<a href="https://baike.baidu.com/item/DRX/50250966?fromModule=lemma_inlink">DRX</a>战队。</p><p>​    <strong>deft</strong>2013年初次登上职业赛场的舞台，效力于<strong>MVP</strong>战队（后被三星收购），三星当时拥有两支战队，两只都是世界顶尖的水平，故这十人也被人们冠以<strong>三星十子</strong>的美称，而deft就是这十人中年级第二小的弟弟。那年deft效力的<strong>三星蓝</strong>在各种赛事上都赢过了<strong>三星白</strong>却在全球总决赛的4强赛中以0：3负于三星白。虽然结局令人惋惜，但deft年纪还小未来可期，<strong>这本应该是deft这位顶级ad谱写传奇的第一步，却不曾想这却成为deft在未来近十年内在世界赛内取得的最好的成绩</strong></p><p>​    在2014年deft远渡重洋来到中国的edg并助力edg成为当时中国独一档的顶尖强队，拿下了包括德玛西亚杯，2015lpl春季赛冠军，并在那年的拳头第一次举办的msi——这一世界上含金量仅次于s赛的世界大赛中战胜了当时被奉为神话的SKT战队，成为了第一届msi冠军，也为中国拿到了第一个国际赛事的冠军，<strong>但令人惋惜的是在deft巅峰期，这届msi成为了他在国际联赛中的唯一高光</strong></p><p>​    在2015年及2016年deft都作为edg的王牌承载着几乎全中国观众的希望登上s赛的舞台但最终都饮恨倒在了8强，而他也最终做出了离开edg的决定，在2016年的年度颁奖典礼上deft也成为了那一年的年度mvp，在中国观众的一声声deft的呐喊与欢呼中，<strong>他留下了离别的泪水，是感激也是不舍，是对中国观众支持的感动，也代表着他的成长，从曾经三星十子中爱哭的弟弟到坚强的逐梦人的成长。</strong></p><p>​    但命运似乎永远都在与deft的开玩笑，处于巅峰末期的deft加入了韩国的“银河战舰”kt，却没能进入2017的世界赛，在2018年deft继续保持在最高水平的竞技水平，帮助kt取得韩国夏季赛冠军，成为了当时最被看好的s赛冠军的有力竞争者。但造化弄人，他们在8强赛中遇上了当年的世界冠军ig，再次倒在了八强，<strong>在deft职业生涯巅峰的末端他仍然没有突破8强这一瓶颈，命运似乎永远都没有站在他这一边。</strong></p><p>   于是在2019年他再次转会kz，在这一年他甚至没能进入季后赛。19年是个对于deft特别却又残忍的一年，在这一年中他取得了他人生中最差的成绩，而曾经的三星十子除他以外全部退役，他的竞技状态也随着年纪的增长开始走向低谷，<strong>他已从队伍中最小的弟弟不知不觉的成为了队内的老大哥，成为了三星十子中最后的明星。</strong></p><p>   在2020，2021年中deft分别效力于drx，hle战队，但无论他如何辗转，队友如何变幻，不变的却是8强这一看似他永远都无法突破的心魔。在他职业生涯的第九年，以五次s赛8强的成绩，他也被人们戏称为“五八同城”。而在2022年deft回到了老东家drx，而这一年他的队友是blg的弃子kingen与zeka，dk的弃子beryl，和才取得联赛倒数成绩的pyosik，所有人都不看好这一支队伍，也一致认为这将是deft生涯的最后一年，随着新生代选手的脱颖而出，人们逐渐开始不在关注这位老将，更不会对他抱有太大期望，<strong>但永远不要低估一位坚守赛场数十年如一日的老将取胜的决心，与一位最纯粹的追梦人历尽坎坷后所拥有的坚定信念</strong></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/Clear1oveE.github.io/main/2022/11/20/postDeft/007GrnJqgy1h7g9ov4k3sj30u02gkh1q.jpg"></p><p>drx在国内正如赛前无数人所预期的一样，成绩平平，甚至以3:2的成绩艰难击败slb后才堪堪以四号种子的身份进入世界赛。但命运似乎在deft辗转10年后依然没有对他露出笑容，这支drx从入围赛开始就恶战不断，从msi冠军rng到夺冠热门tes，再到8强赛的2021年世界冠军edg，再到lck春季赛冠军，两届世界冠军geng，每场比赛都没人看好drx，但drx却把把“爆冷”在与一众强敌的对决中不断进化，<strong>在击败edg后，这也是deft历经2942天重新突破八强，这一次deft的眼泪名为坚持与热爱。</strong></p><p><strong>”究竟什么样的结局才配得上这一路上的颠沛流离“</strong>在解说为这位老将真心呐喊的声音中，deft终于第一次来到了他人生中梦寐以求的s赛的决赛舞台，而迎战他们的是在这届s赛中以碾压之姿进入决赛，英雄联盟历史上最传奇的战队——SKT。而即使他千辛万苦用尽十年时光才到达这个舞台，命运女神似乎仍然在与他开玩笑，渴望将他拉入深渊。在比赛中drx三次被抢大龙，有两次甚至是被ad抢的，一次次丢失大龙不断挑战着选手们的心态，就连我当时也觉得运气似乎真的不站在drx这边，deft真要止步于此了。<strong>但正如s12主题曲《逐星》所唱到的那样“生命若不息，前行永不停，逐星至天明。”</strong>在重压下deft甘愿做为队伍的绿叶默默抗压，把舞台给到了自己的后辈们，而他们也没有辜负deft这一老大哥的信任，在队伍一次次陷入绝境时交替挺身而出。随着最后一条远古龙被打野稳稳拿下，<strong>deft终于拿到了他追逐十年梦寐以求的全球冠军，创造了s赛近12年以来最触动人心的奇迹</strong>，<strong>那一刻DRX给我带来的感动是超越了“输赢”“胜负”，来到另一个层面。他们夺冠的过程，展现了电子竞技与其他体育项目共同蕴含着的竞技精神，是在逆境中不屈不挠，绝望时拼搏出一线生机，最终实现超越自我，散发着闪耀光芒的人性光辉。这就是竞技体育的魅力，这就是奥林匹克精神。谢谢deft圆满的结局没有让纯粹的理想主义成为悲歌，他的名字必将被所有召唤师铭记。</strong></p><blockquote><p>夺冠后Deft的新ins：</p></blockquote><blockquote><p>过了一段时间了，我终于感受到这一切不是梦。我每一天都看着很多人说：“你拿不到冠军” ，“伤病以后就结束了”，“年纪大了就结束了..”我好像花了10年的时间，才有资格去说你们这些话是错的。希望我和我们队的胜利能成为那些正在经历比我更艰难日子的人们希望，最重要的是不屈服的心…今年真的很有趣，大家给予了我很多支持，这一年是我人生中最幸福的一年，一直以来很感谢大家.</p></blockquote><p><strong>就像deft所说的那样“My dance is not over yet。”</strong>deft的最后一舞已经完美落幕了，但这样一位如此纯粹历经无数坎坷仍初心如故的追梦人向我向，全世界展示了坚持所创造的奇迹，特别在如今的时代里deft的夺冠更是有着无可估量的正面作用。<strong>在摆烂之风畅行的现在，越来越多的人开始学会接受现实，接受不是所有努力都有回报，但当deft这样的老将，drx这样没有太多话题的战队用以比热血漫画还艰难的过程和更圆满的结局告诉世人纯粹才是电竞的未来时，我们或许会想起当年爱上lol的原因，回想起当年挑战命运的自己。</strong>也许很多年后的某一天当我们再一次谈论起deft时，除了赞叹他的十年逐梦，终有回响外，更会钦佩他连续十年倒下，又连续十年站起来的勇气与执着，哪怕是遍体鳞伤，哪怕是不被全世界看好，连命运都无法将他击倒的人，真的很酷。<strong>如果有一天你觉得命运不公，希望你能回来再听听deft与drx的故事，不是所有人都是天选，但你永远是唯一。</strong></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/Clear1oveE.github.io/main/2022/11/20/postDeft/1668694542656.png" alt="deft"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/Clear1oveE.github.io/main/2022/11/20/postDeft/1668694545485.jpg" alt="deft"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/Clear1oveE.github.io/main/2022/11/20/postDeft/1668694548357.jpg" alt="deft"></p><p><img src="https://raw.githubusercontent.com/Clear1oveE/Clear1oveE.github.io/main/2022/11/20/postDeft/1668694551086.jpg" alt="deft"></p>]]></content>
      
      
      <categories>
          
          <category> league of legends </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
